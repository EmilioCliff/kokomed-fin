// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: clients.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const countClientsByCategory = `-- name: CountClientsByCategory :one
SELECT COUNT(*) AS total_clients
FROM clients c
JOIN branches b ON c.branch_id = b.id
WHERE 
    (
        COALESCE(?, '') = '' 
        OR LOWER(c.full_name) LIKE ?
        OR LOWER(c.phone_number) LIKE ?
    )
    AND (
        ? IS NULL OR c.active = ?
    )
`

type CountClientsByCategoryParams struct {
	Column1     interface{}  `json:"column_1"`
	FullName    string       `json:"full_name"`
	PhoneNumber string       `json:"phone_number"`
	Active      sql.NullBool `json:"active"`
}

func (q *Queries) CountClientsByCategory(ctx context.Context, arg CountClientsByCategoryParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countClientsByCategory,
		arg.Column1,
		arg.FullName,
		arg.PhoneNumber,
		arg.Active,
		arg.Active,
	)
	var total_clients int64
	err := row.Scan(&total_clients)
	return total_clients, err
}

const createClient = `-- name: CreateClient :execresult
INSERT INTO clients (full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, updated_by, updated_at, created_by) 
VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    true,
    ?,
    ?,
    ?,
    CURRENT_TIMESTAMP,
    ?
)
`

type CreateClientParams struct {
	FullName      string         `json:"full_name"`
	PhoneNumber   string         `json:"phone_number"`
	IDNumber      sql.NullString `json:"id_number"`
	Dob           sql.NullTime   `json:"dob"`
	Gender        ClientsGender  `json:"gender"`
	BranchID      uint32         `json:"branch_id"`
	AssignedStaff uint32         `json:"assigned_staff"`
	UpdatedBy     uint32         `json:"updated_by"`
	CreatedBy     uint32         `json:"created_by"`
}

func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createClient,
		arg.FullName,
		arg.PhoneNumber,
		arg.IDNumber,
		arg.Dob,
		arg.Gender,
		arg.BranchID,
		arg.AssignedStaff,
		arg.UpdatedBy,
		arg.CreatedBy,
	)
}

const deductClientOverpayment = `-- name: DeductClientOverpayment :execresult
UPDATE clients
SET overpayment = overpayment - ?
WHERE id = ?
`

type DeductClientOverpaymentParams struct {
	Overpayment float64 `json:"overpayment"`
	ID          uint32  `json:"id"`
}

func (q *Queries) DeductClientOverpayment(ctx context.Context, arg DeductClientOverpaymentParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deductClientOverpayment, arg.Overpayment, arg.ID)
}

const deleteClient = `-- name: DeleteClient :execresult
DELETE FROM clients WHERE id = ?
`

func (q *Queries) DeleteClient(ctx context.Context, id uint32) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteClient, id)
}

const getClient = `-- name: GetClient :one
SELECT id, full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, overpayment, updated_by, updated_at, created_by, created_at FROM clients WHERE id = ? LIMIT 1
`

func (q *Queries) GetClient(ctx context.Context, id uint32) (Client, error) {
	row := q.db.QueryRowContext(ctx, getClient, id)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.PhoneNumber,
		&i.IDNumber,
		&i.Dob,
		&i.Gender,
		&i.Active,
		&i.BranchID,
		&i.AssignedStaff,
		&i.Overpayment,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getClientByPhoneNumber = `-- name: GetClientByPhoneNumber :one
SELECT id, full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, overpayment, updated_by, updated_at, created_by, created_at FROM clients WHERE phone_number = ? LIMIT 1
`

func (q *Queries) GetClientByPhoneNumber(ctx context.Context, phoneNumber string) (Client, error) {
	row := q.db.QueryRowContext(ctx, getClientByPhoneNumber, phoneNumber)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.PhoneNumber,
		&i.IDNumber,
		&i.Dob,
		&i.Gender,
		&i.Active,
		&i.BranchID,
		&i.AssignedStaff,
		&i.Overpayment,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getClientFullData = `-- name: GetClientFullData :one
SELECT 
    c.id AS client_id,
    c.full_name AS client_name,
    c.phone_number AS client_phone,
    c.id_number,
    c.dob,
    c.gender,
    c.active,
    c.overpayment,
    b.name AS branch_name,
    c.created_at AS client_created_at,
    -- c.due_amount AS client_due_amount,

    -- Assigned Staff
    assigned.id AS assigned_user_id,
    assigned.full_name AS assigned_user_name,
    assigned.phone_number AS assigned_user_phone,
    assigned.email AS assigned_user_email,
    assigned.role AS assigned_user_role,

    -- Created By
    created.id AS created_by_id,
    created.full_name AS created_by_name,
    created.phone_number AS created_by_phone,
    created.email AS created_by_email,
    created.role AS created_by_role

FROM clients c
JOIN branches b ON c.branch_id = b.id
JOIN users assigned ON c.assigned_staff = assigned.id
JOIN users created ON c.created_by = created.id

WHERE c.id = ?
`

type GetClientFullDataRow struct {
	ClientID          uint32         `json:"client_id"`
	ClientName        string         `json:"client_name"`
	ClientPhone       string         `json:"client_phone"`
	IDNumber          sql.NullString `json:"id_number"`
	Dob               sql.NullTime   `json:"dob"`
	Gender            ClientsGender  `json:"gender"`
	Active            bool           `json:"active"`
	Overpayment       float64        `json:"overpayment"`
	BranchName        string         `json:"branch_name"`
	ClientCreatedAt   time.Time      `json:"client_created_at"`
	AssignedUserID    uint32         `json:"assigned_user_id"`
	AssignedUserName  string         `json:"assigned_user_name"`
	AssignedUserPhone string         `json:"assigned_user_phone"`
	AssignedUserEmail string         `json:"assigned_user_email"`
	AssignedUserRole  UsersRole      `json:"assigned_user_role"`
	CreatedByID       uint32         `json:"created_by_id"`
	CreatedByName     string         `json:"created_by_name"`
	CreatedByPhone    string         `json:"created_by_phone"`
	CreatedByEmail    string         `json:"created_by_email"`
	CreatedByRole     UsersRole      `json:"created_by_role"`
}

// JOIN users updated ON c.updated_by = updated.id
func (q *Queries) GetClientFullData(ctx context.Context, id uint32) (GetClientFullDataRow, error) {
	row := q.db.QueryRowContext(ctx, getClientFullData, id)
	var i GetClientFullDataRow
	err := row.Scan(
		&i.ClientID,
		&i.ClientName,
		&i.ClientPhone,
		&i.IDNumber,
		&i.Dob,
		&i.Gender,
		&i.Active,
		&i.Overpayment,
		&i.BranchName,
		&i.ClientCreatedAt,
		&i.AssignedUserID,
		&i.AssignedUserName,
		&i.AssignedUserPhone,
		&i.AssignedUserEmail,
		&i.AssignedUserRole,
		&i.CreatedByID,
		&i.CreatedByName,
		&i.CreatedByPhone,
		&i.CreatedByEmail,
		&i.CreatedByRole,
	)
	return i, err
}

const getClientIDByPhoneNumber = `-- name: GetClientIDByPhoneNumber :one
SELECT id FROM clients WHERE phone_number = ? LIMIT 1
`

func (q *Queries) GetClientIDByPhoneNumber(ctx context.Context, phoneNumber string) (uint32, error) {
	row := q.db.QueryRowContext(ctx, getClientIDByPhoneNumber, phoneNumber)
	var id uint32
	err := row.Scan(&id)
	return id, err
}

const getClientOverpayment = `-- name: GetClientOverpayment :one
SELECT overpayment FROM clients WHERE id = ? LIMIT 1
`

func (q *Queries) GetClientOverpayment(ctx context.Context, id uint32) (float64, error) {
	row := q.db.QueryRowContext(ctx, getClientOverpayment, id)
	var overpayment float64
	err := row.Scan(&overpayment)
	return overpayment, err
}

const getClientWithBranchName = `-- name: GetClientWithBranchName :one
SELECT c.id, c.full_name, c.phone_number, c.id_number, c.dob, c.gender, c.active, c.branch_id, c.assigned_staff, c.overpayment, c.updated_by, c.updated_at, c.created_by, c.created_at, b.name AS branch_name 
FROM clients c 
JOIN branches b ON c.branch_id = b.id 
WHERE c.id = ? LIMIT 1
`

type GetClientWithBranchNameRow struct {
	ID            uint32         `json:"id"`
	FullName      string         `json:"full_name"`
	PhoneNumber   string         `json:"phone_number"`
	IDNumber      sql.NullString `json:"id_number"`
	Dob           sql.NullTime   `json:"dob"`
	Gender        ClientsGender  `json:"gender"`
	Active        bool           `json:"active"`
	BranchID      uint32         `json:"branch_id"`
	AssignedStaff uint32         `json:"assigned_staff"`
	Overpayment   float64        `json:"overpayment"`
	UpdatedBy     uint32         `json:"updated_by"`
	UpdatedAt     time.Time      `json:"updated_at"`
	CreatedBy     uint32         `json:"created_by"`
	CreatedAt     time.Time      `json:"created_at"`
	BranchName    string         `json:"branch_name"`
}

func (q *Queries) GetClientWithBranchName(ctx context.Context, id uint32) (GetClientWithBranchNameRow, error) {
	row := q.db.QueryRowContext(ctx, getClientWithBranchName, id)
	var i GetClientWithBranchNameRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.PhoneNumber,
		&i.IDNumber,
		&i.Dob,
		&i.Gender,
		&i.Active,
		&i.BranchID,
		&i.AssignedStaff,
		&i.Overpayment,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.BranchName,
	)
	return i, err
}

const helperClient = `-- name: HelperClient :many
SELECT id, full_name, phone_number FROM clients
`

type HelperClientRow struct {
	ID          uint32 `json:"id"`
	FullName    string `json:"full_name"`
	PhoneNumber string `json:"phone_number"`
}

func (q *Queries) HelperClient(ctx context.Context) ([]HelperClientRow, error) {
	rows, err := q.db.QueryContext(ctx, helperClient)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HelperClientRow{}
	for rows.Next() {
		var i HelperClientRow
		if err := rows.Scan(&i.ID, &i.FullName, &i.PhoneNumber); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClients = `-- name: ListClients :many
SELECT id, full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, overpayment, updated_by, updated_at, created_by, created_at FROM clients LIMIT ? OFFSET ?
`

type ListClientsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListClients(ctx context.Context, arg ListClientsParams) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, listClients, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Client{}
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.PhoneNumber,
			&i.IDNumber,
			&i.Dob,
			&i.Gender,
			&i.Active,
			&i.BranchID,
			&i.AssignedStaff,
			&i.Overpayment,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientsByActiveStatus = `-- name: ListClientsByActiveStatus :many
SELECT id, full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, overpayment, updated_by, updated_at, created_by, created_at FROM clients WHERE active = ? LIMIT ? OFFSET ?
`

type ListClientsByActiveStatusParams struct {
	Active bool  `json:"active"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListClientsByActiveStatus(ctx context.Context, arg ListClientsByActiveStatusParams) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, listClientsByActiveStatus, arg.Active, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Client{}
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.PhoneNumber,
			&i.IDNumber,
			&i.Dob,
			&i.Gender,
			&i.Active,
			&i.BranchID,
			&i.AssignedStaff,
			&i.Overpayment,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientsByBranch = `-- name: ListClientsByBranch :many
SELECT id, full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, overpayment, updated_by, updated_at, created_by, created_at FROM clients WHERE branch_id = ? LIMIT ? OFFSET ?
`

type ListClientsByBranchParams struct {
	BranchID uint32 `json:"branch_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) ListClientsByBranch(ctx context.Context, arg ListClientsByBranchParams) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, listClientsByBranch, arg.BranchID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Client{}
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.PhoneNumber,
			&i.IDNumber,
			&i.Dob,
			&i.Gender,
			&i.Active,
			&i.BranchID,
			&i.AssignedStaff,
			&i.Overpayment,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientsByCategory = `-- name: ListClientsByCategory :many
SELECT 
    c.id, c.full_name, c.phone_number, c.id_number, c.dob, c.gender, c.active, 
    c.branch_id, c.assigned_staff, c.overpayment, c.updated_by, 
    c.updated_at, c.created_at, c.created_by, 
    b.name AS branch_name,
    COALESCE(SUM(DISTINCT COALESCE(p.repay_amount, 0) - COALESCE(l.paid_amount, 0)), 0) AS dueAmount,
    -- Assigned User Details
    assigned.id AS assigned_user_id,
    assigned.full_name AS assigned_user_name,
    assigned.phone_number AS assigned_user_phone,
    assigned.email AS assigned_user_email,
    assigned.role AS assigned_user_role,

    -- UpdatedBy User Details
    updated.id AS updated_user_id,
    updated.full_name AS updated_user_name,
    updated.phone_number AS updated_user_phone,
    updated.email AS updated_user_email,
    updated.role AS updated_user_role,

    -- Created By User Details
    created.id AS created_user_id,
    created.full_name AS created_user_name,
    created.phone_number AS created_user_phone,
    created.email AS created_user_email,
    created.role AS created_user_role
FROM clients c
JOIN branches b ON c.branch_id = b.id
LEFT JOIN loans l ON c.id = l.client_id AND l.status = 'ACTIVE'
LEFT JOIN products p ON l.product_id = p.id
LEFT JOIN users assigned ON c.assigned_staff = assigned.id
LEFT JOIN users updated ON c.updated_by = updated.id
LEFT JOIN users created ON c.created_by = created.id
WHERE 
    (
        COALESCE(?, '') = '' 
        OR LOWER(c.full_name) LIKE ?
        OR LOWER(c.phone_number) LIKE ?
    )
    AND (
        ? IS NULL OR c.active = ?
    )
GROUP BY 
    c.id, c.full_name, c.phone_number, c.id_number, c.dob, c.gender, c.active, 
    c.branch_id, c.assigned_staff, c.overpayment, c.updated_by, 
    c.updated_at, c.created_at, c.created_by, b.name,
    assigned.id, assigned.full_name, assigned.phone_number, assigned.email, assigned.role,
    updated.id, updated.full_name, updated.phone_number, updated.email, updated.role,
    created.id, created.full_name, created.phone_number, created.email, created.role
ORDER BY c.created_at DESC
LIMIT ? OFFSET ?
`

type ListClientsByCategoryParams struct {
	Column1     interface{}  `json:"column_1"`
	FullName    string       `json:"full_name"`
	PhoneNumber string       `json:"phone_number"`
	Active      sql.NullBool `json:"active"`
	Limit       int32        `json:"limit"`
	Offset      int32        `json:"offset"`
}

type ListClientsByCategoryRow struct {
	ID                uint32         `json:"id"`
	FullName          string         `json:"full_name"`
	PhoneNumber       string         `json:"phone_number"`
	IDNumber          sql.NullString `json:"id_number"`
	Dob               sql.NullTime   `json:"dob"`
	Gender            ClientsGender  `json:"gender"`
	Active            bool           `json:"active"`
	BranchID          uint32         `json:"branch_id"`
	AssignedStaff     uint32         `json:"assigned_staff"`
	Overpayment       float64        `json:"overpayment"`
	UpdatedBy         uint32         `json:"updated_by"`
	UpdatedAt         time.Time      `json:"updated_at"`
	CreatedAt         time.Time      `json:"created_at"`
	CreatedBy         uint32         `json:"created_by"`
	BranchName        string         `json:"branch_name"`
	Dueamount         interface{}    `json:"dueamount"`
	AssignedUserID    sql.NullInt32  `json:"assigned_user_id"`
	AssignedUserName  sql.NullString `json:"assigned_user_name"`
	AssignedUserPhone sql.NullString `json:"assigned_user_phone"`
	AssignedUserEmail sql.NullString `json:"assigned_user_email"`
	AssignedUserRole  NullUsersRole  `json:"assigned_user_role"`
	UpdatedUserID     sql.NullInt32  `json:"updated_user_id"`
	UpdatedUserName   sql.NullString `json:"updated_user_name"`
	UpdatedUserPhone  sql.NullString `json:"updated_user_phone"`
	UpdatedUserEmail  sql.NullString `json:"updated_user_email"`
	UpdatedUserRole   NullUsersRole  `json:"updated_user_role"`
	CreatedUserID     sql.NullInt32  `json:"created_user_id"`
	CreatedUserName   sql.NullString `json:"created_user_name"`
	CreatedUserPhone  sql.NullString `json:"created_user_phone"`
	CreatedUserEmail  sql.NullString `json:"created_user_email"`
	CreatedUserRole   NullUsersRole  `json:"created_user_role"`
}

func (q *Queries) ListClientsByCategory(ctx context.Context, arg ListClientsByCategoryParams) ([]ListClientsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listClientsByCategory,
		arg.Column1,
		arg.FullName,
		arg.PhoneNumber,
		arg.Active,
		arg.Active,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListClientsByCategoryRow{}
	for rows.Next() {
		var i ListClientsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.PhoneNumber,
			&i.IDNumber,
			&i.Dob,
			&i.Gender,
			&i.Active,
			&i.BranchID,
			&i.AssignedStaff,
			&i.Overpayment,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.BranchName,
			&i.Dueamount,
			&i.AssignedUserID,
			&i.AssignedUserName,
			&i.AssignedUserPhone,
			&i.AssignedUserEmail,
			&i.AssignedUserRole,
			&i.UpdatedUserID,
			&i.UpdatedUserName,
			&i.UpdatedUserPhone,
			&i.UpdatedUserEmail,
			&i.UpdatedUserRole,
			&i.CreatedUserID,
			&i.CreatedUserName,
			&i.CreatedUserPhone,
			&i.CreatedUserEmail,
			&i.CreatedUserRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nullifyClientOverpayment = `-- name: NullifyClientOverpayment :execresult
UPDATE clients
SET overpayment = 0
WHERE id = ?
`

func (q *Queries) NullifyClientOverpayment(ctx context.Context, id uint32) (sql.Result, error) {
	return q.db.ExecContext(ctx, nullifyClientOverpayment, id)
}

const updateClient = `-- name: UpdateClient :execresult
UPDATE clients 
    SET full_name = ?,
    phone_number = ?,
    gender = ?,
    assigned_staff = ?,
    branch_id = ?,
    active = ?,
    id_number = coalesce(?, id_number),
    dob = coalesce(?, dob),
    updated_at = CURRENT_TIMESTAMP,
    updated_by = ?
WHERE id = ?
`

type UpdateClientParams struct {
	FullName      string         `json:"full_name"`
	PhoneNumber   string         `json:"phone_number"`
	Gender        ClientsGender  `json:"gender"`
	AssignedStaff uint32         `json:"assigned_staff"`
	BranchID      uint32         `json:"branch_id"`
	Active        bool           `json:"active"`
	IDNumber      sql.NullString `json:"id_number"`
	Dob           sql.NullTime   `json:"dob"`
	UpdatedBy     uint32         `json:"updated_by"`
	ID            uint32         `json:"id"`
}

func (q *Queries) UpdateClient(ctx context.Context, arg UpdateClientParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateClient,
		arg.FullName,
		arg.PhoneNumber,
		arg.Gender,
		arg.AssignedStaff,
		arg.BranchID,
		arg.Active,
		arg.IDNumber,
		arg.Dob,
		arg.UpdatedBy,
		arg.ID,
	)
}

const updateClientOverpayment = `-- name: UpdateClientOverpayment :execresult
UPDATE clients
SET overpayment = overpayment + ?
WHERE 
    (phone_number = ? AND ? IS NOT NULL)
    OR 
    (id = ? AND ? IS NOT NULL)
`

type UpdateClientOverpaymentParams struct {
	Overpayment float64 `json:"overpayment"`
	PhoneNumber string  `json:"phone_number"`
	ClientID    uint32  `json:"client_id"`
}

func (q *Queries) UpdateClientOverpayment(ctx context.Context, arg UpdateClientOverpaymentParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateClientOverpayment,
		arg.Overpayment,
		arg.PhoneNumber,
		arg.PhoneNumber,
		arg.ClientID,
		arg.ClientID,
	)
}
