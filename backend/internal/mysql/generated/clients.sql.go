// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: clients.sql

package generated

import (
	"context"
	"database/sql"
)

const createClient = `-- name: CreateClient :execresult
INSERT INTO clients (full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, updated_by, updated_at, created_by) 
VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    CURRENT_TIMESTAMP,
    ?
)
`

type CreateClientParams struct {
	FullName      string         `json:"full_name"`
	PhoneNumber   string         `json:"phone_number"`
	IDNumber      sql.NullString `json:"id_number"`
	Dob           sql.NullTime   `json:"dob"`
	Gender        ClientsGender  `json:"gender"`
	Active        bool           `json:"active"`
	BranchID      uint32         `json:"branch_id"`
	AssignedStaff uint32         `json:"assigned_staff"`
	UpdatedBy     uint32         `json:"updated_by"`
	CreatedBy     uint32         `json:"created_by"`
}

func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createClient,
		arg.FullName,
		arg.PhoneNumber,
		arg.IDNumber,
		arg.Dob,
		arg.Gender,
		arg.Active,
		arg.BranchID,
		arg.AssignedStaff,
		arg.UpdatedBy,
		arg.CreatedBy,
	)
}

const deleteClient = `-- name: DeleteClient :execresult
DELETE FROM clients WHERE id = ?
`

func (q *Queries) DeleteClient(ctx context.Context, id uint32) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteClient, id)
}

const getClient = `-- name: GetClient :one
SELECT id, full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, overpayment, updated_by, updated_at, created_by, created_at FROM clients WHERE id = ? LIMIT 1
`

func (q *Queries) GetClient(ctx context.Context, id uint32) (Client, error) {
	row := q.db.QueryRowContext(ctx, getClient, id)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.PhoneNumber,
		&i.IDNumber,
		&i.Dob,
		&i.Gender,
		&i.Active,
		&i.BranchID,
		&i.AssignedStaff,
		&i.Overpayment,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getClientByPhoneNumber = `-- name: GetClientByPhoneNumber :one
SELECT id, full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, overpayment, updated_by, updated_at, created_by, created_at FROM clients WHERE phone_number = ? LIMIT 1
`

func (q *Queries) GetClientByPhoneNumber(ctx context.Context, phoneNumber string) (Client, error) {
	row := q.db.QueryRowContext(ctx, getClientByPhoneNumber, phoneNumber)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.PhoneNumber,
		&i.IDNumber,
		&i.Dob,
		&i.Gender,
		&i.Active,
		&i.BranchID,
		&i.AssignedStaff,
		&i.Overpayment,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const listClients = `-- name: ListClients :many
SELECT id, full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, overpayment, updated_by, updated_at, created_by, created_at FROM clients LIMIT ? OFFSET ?
`

type ListClientsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListClients(ctx context.Context, arg ListClientsParams) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, listClients, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Client
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.PhoneNumber,
			&i.IDNumber,
			&i.Dob,
			&i.Gender,
			&i.Active,
			&i.BranchID,
			&i.AssignedStaff,
			&i.Overpayment,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientsByActiveStatus = `-- name: ListClientsByActiveStatus :many
SELECT id, full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, overpayment, updated_by, updated_at, created_by, created_at FROM clients WHERE active = ? LIMIT ? OFFSET ?
`

type ListClientsByActiveStatusParams struct {
	Active bool  `json:"active"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListClientsByActiveStatus(ctx context.Context, arg ListClientsByActiveStatusParams) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, listClientsByActiveStatus, arg.Active, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Client
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.PhoneNumber,
			&i.IDNumber,
			&i.Dob,
			&i.Gender,
			&i.Active,
			&i.BranchID,
			&i.AssignedStaff,
			&i.Overpayment,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientsByBranch = `-- name: ListClientsByBranch :many
SELECT id, full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, overpayment, updated_by, updated_at, created_by, created_at FROM clients WHERE branch_id = ? LIMIT ? OFFSET ?
`

type ListClientsByBranchParams struct {
	BranchID uint32 `json:"branch_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) ListClientsByBranch(ctx context.Context, arg ListClientsByBranchParams) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, listClientsByBranch, arg.BranchID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Client
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.PhoneNumber,
			&i.IDNumber,
			&i.Dob,
			&i.Gender,
			&i.Active,
			&i.BranchID,
			&i.AssignedStaff,
			&i.Overpayment,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClient = `-- name: UpdateClient :execresult
UPDATE clients 
    SET full_name = ?,
    phone_number = ?,
    id_number = coalesce(?, id_number),
    dob = coalesce(?, dob),
    gender = ?,
    active = ?,
    branch_id = ?,
    assigned_staff = ?,
    updated_at = CURRENT_TIMESTAMP,
    updated_by = ?
WHERE id = ?
`

type UpdateClientParams struct {
	FullName      string         `json:"full_name"`
	PhoneNumber   string         `json:"phone_number"`
	IDNumber      sql.NullString `json:"id_number"`
	Dob           sql.NullTime   `json:"dob"`
	Gender        ClientsGender  `json:"gender"`
	Active        bool           `json:"active"`
	BranchID      uint32         `json:"branch_id"`
	AssignedStaff uint32         `json:"assigned_staff"`
	UpdatedBy     uint32         `json:"updated_by"`
	ID            uint32         `json:"id"`
}

func (q *Queries) UpdateClient(ctx context.Context, arg UpdateClientParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateClient,
		arg.FullName,
		arg.PhoneNumber,
		arg.IDNumber,
		arg.Dob,
		arg.Gender,
		arg.Active,
		arg.BranchID,
		arg.AssignedStaff,
		arg.UpdatedBy,
		arg.ID,
	)
}
