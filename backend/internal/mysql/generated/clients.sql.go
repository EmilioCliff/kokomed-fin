// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: clients.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const countClientsByCategory = `-- name: CountClientsByCategory :one
SELECT COUNT(*) AS total_clients
FROM clients c
JOIN branches b ON c.branch_id = b.id
WHERE 
    (
        COALESCE(?, '') = '' 
        OR LOWER(c.full_name) LIKE ?
        OR LOWER(c.phone_number) LIKE ?
    )
    AND (
        ? IS NULL OR c.active = ?
    )
`

type CountClientsByCategoryParams struct {
	Column1     interface{}  `json:"column_1"`
	FullName    string       `json:"full_name"`
	PhoneNumber string       `json:"phone_number"`
	Active      sql.NullBool `json:"active"`
}

func (q *Queries) CountClientsByCategory(ctx context.Context, arg CountClientsByCategoryParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countClientsByCategory,
		arg.Column1,
		arg.FullName,
		arg.PhoneNumber,
		arg.Active,
		arg.Active,
	)
	var total_clients int64
	err := row.Scan(&total_clients)
	return total_clients, err
}

const createClient = `-- name: CreateClient :execresult
INSERT INTO clients (full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, updated_by, updated_at, created_by) 
VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    true,
    ?,
    ?,
    ?,
    CURRENT_TIMESTAMP,
    ?
)
`

type CreateClientParams struct {
	FullName      string         `json:"full_name"`
	PhoneNumber   string         `json:"phone_number"`
	IDNumber      sql.NullString `json:"id_number"`
	Dob           sql.NullTime   `json:"dob"`
	Gender        ClientsGender  `json:"gender"`
	BranchID      uint32         `json:"branch_id"`
	AssignedStaff uint32         `json:"assigned_staff"`
	UpdatedBy     uint32         `json:"updated_by"`
	CreatedBy     uint32         `json:"created_by"`
}

func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createClient,
		arg.FullName,
		arg.PhoneNumber,
		arg.IDNumber,
		arg.Dob,
		arg.Gender,
		arg.BranchID,
		arg.AssignedStaff,
		arg.UpdatedBy,
		arg.CreatedBy,
	)
}

const deleteClient = `-- name: DeleteClient :execresult
DELETE FROM clients WHERE id = ?
`

func (q *Queries) DeleteClient(ctx context.Context, id uint32) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteClient, id)
}

const getClient = `-- name: GetClient :one
SELECT id, full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, overpayment, updated_by, updated_at, created_by, created_at FROM clients WHERE id = ? LIMIT 1
`

func (q *Queries) GetClient(ctx context.Context, id uint32) (Client, error) {
	row := q.db.QueryRowContext(ctx, getClient, id)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.PhoneNumber,
		&i.IDNumber,
		&i.Dob,
		&i.Gender,
		&i.Active,
		&i.BranchID,
		&i.AssignedStaff,
		&i.Overpayment,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getClientIDByPhoneNumber = `-- name: GetClientIDByPhoneNumber :one
SELECT id FROM clients WHERE phone_number = ? LIMIT 1
`

func (q *Queries) GetClientIDByPhoneNumber(ctx context.Context, phoneNumber string) (uint32, error) {
	row := q.db.QueryRowContext(ctx, getClientIDByPhoneNumber, phoneNumber)
	var id uint32
	err := row.Scan(&id)
	return id, err
}

const getClientOverpayment = `-- name: GetClientOverpayment :one
SELECT overpayment FROM clients WHERE id = ? LIMIT 1
`

func (q *Queries) GetClientOverpayment(ctx context.Context, id uint32) (float64, error) {
	row := q.db.QueryRowContext(ctx, getClientOverpayment, id)
	var overpayment float64
	err := row.Scan(&overpayment)
	return overpayment, err
}

const helperClient = `-- name: HelperClient :many
SELECT id, full_name, phone_number FROM clients
`

type HelperClientRow struct {
	ID          uint32 `json:"id"`
	FullName    string `json:"full_name"`
	PhoneNumber string `json:"phone_number"`
}

func (q *Queries) HelperClient(ctx context.Context) ([]HelperClientRow, error) {
	rows, err := q.db.QueryContext(ctx, helperClient)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HelperClientRow{}
	for rows.Next() {
		var i HelperClientRow
		if err := rows.Scan(&i.ID, &i.FullName, &i.PhoneNumber); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClients = `-- name: ListClients :many
SELECT id, full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, overpayment, updated_by, updated_at, created_by, created_at FROM clients LIMIT ? OFFSET ?
`

type ListClientsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListClients(ctx context.Context, arg ListClientsParams) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, listClients, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Client{}
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.PhoneNumber,
			&i.IDNumber,
			&i.Dob,
			&i.Gender,
			&i.Active,
			&i.BranchID,
			&i.AssignedStaff,
			&i.Overpayment,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientsByActiveStatus = `-- name: ListClientsByActiveStatus :many
SELECT id, full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, overpayment, updated_by, updated_at, created_by, created_at FROM clients WHERE active = ? LIMIT ? OFFSET ?
`

type ListClientsByActiveStatusParams struct {
	Active bool  `json:"active"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListClientsByActiveStatus(ctx context.Context, arg ListClientsByActiveStatusParams) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, listClientsByActiveStatus, arg.Active, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Client{}
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.PhoneNumber,
			&i.IDNumber,
			&i.Dob,
			&i.Gender,
			&i.Active,
			&i.BranchID,
			&i.AssignedStaff,
			&i.Overpayment,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientsByBranch = `-- name: ListClientsByBranch :many
SELECT id, full_name, phone_number, id_number, dob, gender, active, branch_id, assigned_staff, overpayment, updated_by, updated_at, created_by, created_at FROM clients WHERE branch_id = ? LIMIT ? OFFSET ?
`

type ListClientsByBranchParams struct {
	BranchID uint32 `json:"branch_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) ListClientsByBranch(ctx context.Context, arg ListClientsByBranchParams) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, listClientsByBranch, arg.BranchID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Client{}
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.PhoneNumber,
			&i.IDNumber,
			&i.Dob,
			&i.Gender,
			&i.Active,
			&i.BranchID,
			&i.AssignedStaff,
			&i.Overpayment,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientsByCategory = `-- name: ListClientsByCategory :many
SELECT 
    c.id, c.full_name, c.phone_number, c.id_number, c.dob, c.gender, c.active, 
    c.branch_id, c.assigned_staff, c.overpayment, c.updated_by, 
    c.updated_at, c.created_at, c.created_by, 
    b.name AS branch_name,
    COALESCE(SUM(DISTINCT COALESCE(p.loan_amount, 0) - COALESCE(l.paid_amount, 0)), 0) AS dueAmount
FROM clients c
JOIN branches b ON c.branch_id = b.id
LEFT JOIN loans l ON c.id = l.client_id AND l.status = 'ACTIVE'
LEFT JOIN products p ON l.product_id = p.id
WHERE 
    (
        COALESCE(?, '') = '' 
        OR LOWER(c.full_name) LIKE ?
        OR LOWER(c.phone_number) LIKE ?
    )
    AND (
        ? IS NULL OR c.active = ?
    )
GROUP BY 
    c.id, c.full_name, c.phone_number, c.id_number, c.dob, c.gender, c.active, 
    c.branch_id, c.assigned_staff, c.overpayment, c.updated_by, 
    c.updated_at, c.created_at, c.created_by, b.name
ORDER BY c.created_at DESC
LIMIT ? OFFSET ?
`

type ListClientsByCategoryParams struct {
	Column1     interface{}  `json:"column_1"`
	FullName    string       `json:"full_name"`
	PhoneNumber string       `json:"phone_number"`
	Active      sql.NullBool `json:"active"`
	Limit       int32        `json:"limit"`
	Offset      int32        `json:"offset"`
}

type ListClientsByCategoryRow struct {
	ID            uint32         `json:"id"`
	FullName      string         `json:"full_name"`
	PhoneNumber   string         `json:"phone_number"`
	IDNumber      sql.NullString `json:"id_number"`
	Dob           sql.NullTime   `json:"dob"`
	Gender        ClientsGender  `json:"gender"`
	Active        bool           `json:"active"`
	BranchID      uint32         `json:"branch_id"`
	AssignedStaff uint32         `json:"assigned_staff"`
	Overpayment   float64        `json:"overpayment"`
	UpdatedBy     uint32         `json:"updated_by"`
	UpdatedAt     time.Time      `json:"updated_at"`
	CreatedAt     time.Time      `json:"created_at"`
	CreatedBy     uint32         `json:"created_by"`
	BranchName    string         `json:"branch_name"`
	Dueamount     interface{}    `json:"dueamount"`
}

func (q *Queries) ListClientsByCategory(ctx context.Context, arg ListClientsByCategoryParams) ([]ListClientsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listClientsByCategory,
		arg.Column1,
		arg.FullName,
		arg.PhoneNumber,
		arg.Active,
		arg.Active,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListClientsByCategoryRow{}
	for rows.Next() {
		var i ListClientsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.PhoneNumber,
			&i.IDNumber,
			&i.Dob,
			&i.Gender,
			&i.Active,
			&i.BranchID,
			&i.AssignedStaff,
			&i.Overpayment,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.BranchName,
			&i.Dueamount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nullifyClientOverpayment = `-- name: NullifyClientOverpayment :execresult
UPDATE clients
SET overpayment = 0
WHERE id = ?
`

func (q *Queries) NullifyClientOverpayment(ctx context.Context, id uint32) (sql.Result, error) {
	return q.db.ExecContext(ctx, nullifyClientOverpayment, id)
}

const updateClient = `-- name: UpdateClient :execresult
UPDATE clients 
    SET id_number = coalesce(?, id_number),
    dob = coalesce(?, dob),
    active = coalesce(?, active),
    branch_id = coalesce(?, branch_id),
    updated_at = CURRENT_TIMESTAMP,
    updated_by = ?
WHERE id = ?
`

type UpdateClientParams struct {
	IDNumber  sql.NullString `json:"id_number"`
	Dob       sql.NullTime   `json:"dob"`
	Active    sql.NullBool   `json:"active"`
	BranchID  sql.NullInt32  `json:"branch_id"`
	UpdatedBy uint32         `json:"updated_by"`
	ID        uint32         `json:"id"`
}

func (q *Queries) UpdateClient(ctx context.Context, arg UpdateClientParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateClient,
		arg.IDNumber,
		arg.Dob,
		arg.Active,
		arg.BranchID,
		arg.UpdatedBy,
		arg.ID,
	)
}

const updateClientOverpayment = `-- name: UpdateClientOverpayment :execresult

UPDATE clients
SET overpayment = overpayment + ?
WHERE 
    (phone_number = ? AND ? IS NOT NULL)
    OR 
    (id = ? AND ? IS NOT NULL)
`

type UpdateClientOverpaymentParams struct {
	Overpayment float64 `json:"overpayment"`
	PhoneNumber string  `json:"phone_number"`
	ClientID    uint32  `json:"client_id"`
}

// -- name: UpdateClientOverpayment :execresult
// UPDATE clients
//
//	SET overpayment = overpayment + sqlc.arg("overpayment")
//
// WHERE phone_number = sqlc.arg("phone_number");
func (q *Queries) UpdateClientOverpayment(ctx context.Context, arg UpdateClientOverpaymentParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateClientOverpayment,
		arg.Overpayment,
		arg.PhoneNumber,
		arg.PhoneNumber,
		arg.ClientID,
		arg.ClientID,
	)
}
