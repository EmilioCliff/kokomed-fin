// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: loans.sql

package generated

import (
	"context"
	"database/sql"
)

const createLoan = `-- name: CreateLoan :execresult
INSERT INTO loans (product_id, client_id, loan_officer, loan_purpose, due_date, approved_by, disbursed_on, disbursed_by, total_installments, installments_period, status, processing_fee, created_by) 
VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateLoanParams struct {
	ProductID          uint32         `json:"product_id"`
	ClientID           uint32         `json:"client_id"`
	LoanOfficer        uint32         `json:"loan_officer"`
	LoanPurpose        sql.NullString `json:"loan_purpose"`
	DueDate            sql.NullTime   `json:"due_date"`
	ApprovedBy         uint32         `json:"approved_by"`
	DisbursedOn        sql.NullTime   `json:"disbursed_on"`
	DisbursedBy        sql.NullInt32  `json:"disbursed_by"`
	TotalInstallments  uint32         `json:"total_installments"`
	InstallmentsPeriod uint32         `json:"installments_period"`
	Status             LoansStatus    `json:"status"`
	ProcessingFee      float64        `json:"processing_fee"`
	CreatedBy          uint32         `json:"created_by"`
}

func (q *Queries) CreateLoan(ctx context.Context, arg CreateLoanParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createLoan,
		arg.ProductID,
		arg.ClientID,
		arg.LoanOfficer,
		arg.LoanPurpose,
		arg.DueDate,
		arg.ApprovedBy,
		arg.DisbursedOn,
		arg.DisbursedBy,
		arg.TotalInstallments,
		arg.InstallmentsPeriod,
		arg.Status,
		arg.ProcessingFee,
		arg.CreatedBy,
	)
}

const deleteLoan = `-- name: DeleteLoan :exec
DELETE FROM loans WHERE id = ?
`

func (q *Queries) DeleteLoan(ctx context.Context, id uint32) error {
	_, err := q.db.ExecContext(ctx, deleteLoan, id)
	return err
}

const disburseLoan = `-- name: DisburseLoan :execresult
UPDATE loans 
    SET disbursed_on = ?,
    disbursed_by = ?,
    due_date = ?
WHERE id = ?
`

type DisburseLoanParams struct {
	DisbursedOn sql.NullTime  `json:"disbursed_on"`
	DisbursedBy sql.NullInt32 `json:"disbursed_by"`
	DueDate     sql.NullTime  `json:"due_date"`
	ID          uint32        `json:"id"`
}

func (q *Queries) DisburseLoan(ctx context.Context, arg DisburseLoanParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, disburseLoan,
		arg.DisbursedOn,
		arg.DisbursedBy,
		arg.DueDate,
		arg.ID,
	)
}

const getLoan = `-- name: GetLoan :one
SELECT id, product_id, client_id, loan_officer, loan_purpose, due_date, approved_by, disbursed_on, disbursed_by, total_installments, installments_period, status, processing_fee, paid_amount, updated_by, created_by, created_at FROM loans WHERE id = ? LIMIT 1
`

func (q *Queries) GetLoan(ctx context.Context, id uint32) (Loan, error) {
	row := q.db.QueryRowContext(ctx, getLoan, id)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ClientID,
		&i.LoanOfficer,
		&i.LoanPurpose,
		&i.DueDate,
		&i.ApprovedBy,
		&i.DisbursedOn,
		&i.DisbursedBy,
		&i.TotalInstallments,
		&i.InstallmentsPeriod,
		&i.Status,
		&i.ProcessingFee,
		&i.PaidAmount,
		&i.UpdatedBy,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const listLoans = `-- name: ListLoans :many
SELECT id, product_id, client_id, loan_officer, loan_purpose, due_date, approved_by, disbursed_on, disbursed_by, total_installments, installments_period, status, processing_fee, paid_amount, updated_by, created_by, created_at FROM loans LIMIT ? OFFSET ?
`

type ListLoansParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListLoans(ctx context.Context, arg ListLoansParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listLoans, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Loan
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ClientID,
			&i.LoanOfficer,
			&i.LoanPurpose,
			&i.DueDate,
			&i.ApprovedBy,
			&i.DisbursedOn,
			&i.DisbursedBy,
			&i.TotalInstallments,
			&i.InstallmentsPeriod,
			&i.Status,
			&i.ProcessingFee,
			&i.PaidAmount,
			&i.UpdatedBy,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByClient = `-- name: ListLoansByClient :many
SELECT id, product_id, client_id, loan_officer, loan_purpose, due_date, approved_by, disbursed_on, disbursed_by, total_installments, installments_period, status, processing_fee, paid_amount, updated_by, created_by, created_at FROM loans WHERE client_id = ? LIMIT ? OFFSET ?
`

type ListLoansByClientParams struct {
	ClientID uint32 `json:"client_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) ListLoansByClient(ctx context.Context, arg ListLoansByClientParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listLoansByClient, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Loan
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ClientID,
			&i.LoanOfficer,
			&i.LoanPurpose,
			&i.DueDate,
			&i.ApprovedBy,
			&i.DisbursedOn,
			&i.DisbursedBy,
			&i.TotalInstallments,
			&i.InstallmentsPeriod,
			&i.Status,
			&i.ProcessingFee,
			&i.PaidAmount,
			&i.UpdatedBy,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByLoanOfficer = `-- name: ListLoansByLoanOfficer :many
SELECT id, product_id, client_id, loan_officer, loan_purpose, due_date, approved_by, disbursed_on, disbursed_by, total_installments, installments_period, status, processing_fee, paid_amount, updated_by, created_by, created_at FROM loans WHERE loan_officer = ? LIMIT ? OFFSET ?
`

type ListLoansByLoanOfficerParams struct {
	LoanOfficer uint32 `json:"loan_officer"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) ListLoansByLoanOfficer(ctx context.Context, arg ListLoansByLoanOfficerParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listLoansByLoanOfficer, arg.LoanOfficer, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Loan
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ClientID,
			&i.LoanOfficer,
			&i.LoanPurpose,
			&i.DueDate,
			&i.ApprovedBy,
			&i.DisbursedOn,
			&i.DisbursedBy,
			&i.TotalInstallments,
			&i.InstallmentsPeriod,
			&i.Status,
			&i.ProcessingFee,
			&i.PaidAmount,
			&i.UpdatedBy,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByStatus = `-- name: ListLoansByStatus :many
SELECT id, product_id, client_id, loan_officer, loan_purpose, due_date, approved_by, disbursed_on, disbursed_by, total_installments, installments_period, status, processing_fee, paid_amount, updated_by, created_by, created_at FROM loans WHERE status = ? LIMIT ? OFFSET ?
`

type ListLoansByStatusParams struct {
	Status LoansStatus `json:"status"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListLoansByStatus(ctx context.Context, arg ListLoansByStatusParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listLoansByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Loan
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ClientID,
			&i.LoanOfficer,
			&i.LoanPurpose,
			&i.DueDate,
			&i.ApprovedBy,
			&i.DisbursedOn,
			&i.DisbursedBy,
			&i.TotalInstallments,
			&i.InstallmentsPeriod,
			&i.Status,
			&i.ProcessingFee,
			&i.PaidAmount,
			&i.UpdatedBy,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonDisbursedLoans = `-- name: ListNonDisbursedLoans :many
SELECT id, product_id, client_id, loan_officer, loan_purpose, due_date, approved_by, disbursed_on, disbursed_by, total_installments, installments_period, status, processing_fee, paid_amount, updated_by, created_by, created_at FROM loans WHERE disbursed_on IS NULL LIMIT ? OFFSET ?
`

type ListNonDisbursedLoansParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListNonDisbursedLoans(ctx context.Context, arg ListNonDisbursedLoansParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listNonDisbursedLoans, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Loan
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ClientID,
			&i.LoanOfficer,
			&i.LoanPurpose,
			&i.DueDate,
			&i.ApprovedBy,
			&i.DisbursedOn,
			&i.DisbursedBy,
			&i.TotalInstallments,
			&i.InstallmentsPeriod,
			&i.Status,
			&i.ProcessingFee,
			&i.PaidAmount,
			&i.UpdatedBy,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transferLoan = `-- name: TransferLoan :execresult
UPDATE loans SET loan_officer = ? WHERE id = ?
`

type TransferLoanParams struct {
	LoanOfficer uint32 `json:"loan_officer"`
	ID          uint32 `json:"id"`
}

func (q *Queries) TransferLoan(ctx context.Context, arg TransferLoanParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, transferLoan, arg.LoanOfficer, arg.ID)
}

const updateLoan = `-- name: UpdateLoan :execresult
UPDATE loans 
    SET paid_amount = ?,
    updated_by = coalesce(?, updated_by)
WHERE id = ?
`

type UpdateLoanParams struct {
	PaidAmount float64       `json:"paid_amount"`
	UpdatedBy  sql.NullInt32 `json:"updated_by"`
	ID         uint32        `json:"id"`
}

func (q *Queries) UpdateLoan(ctx context.Context, arg UpdateLoanParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateLoan, arg.PaidAmount, arg.UpdatedBy, arg.ID)
}

const updateLoanStatus = `-- name: UpdateLoanStatus :execresult
UPDATE loans SET status = ? WHERE id = ?
`

type UpdateLoanStatusParams struct {
	Status LoansStatus `json:"status"`
	ID     uint32      `json:"id"`
}

func (q *Queries) UpdateLoanStatus(ctx context.Context, arg UpdateLoanStatusParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateLoanStatus, arg.Status, arg.ID)
}
