// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: loans.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const checkActiveLoanForClient = `-- name: CheckActiveLoanForClient :one
SELECT EXISTS (
    SELECT 1
    FROM loans
    WHERE client_id = ? AND status = 'ACTIVE'
) AS has_active_loan LIMIT 1
`

func (q *Queries) CheckActiveLoanForClient(ctx context.Context, clientID uint32) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkActiveLoanForClient, clientID)
	var has_active_loan bool
	err := row.Scan(&has_active_loan)
	return has_active_loan, err
}

const countClientLoans = `-- name: CountClientLoans :one
SELECT COUNT(*) AS total_loans 
FROM loans l
JOIN products p ON l.product_id = p.id
JOIN clients c ON l.client_id = c.id
JOIN users u ON l.loan_officer = u.id
WHERE 
    (
        COALESCE(?, '') = '' 
        OR FIND_IN_SET(l.status, ?) > 0
    ) AND l.client_id = ?
`

type CountClientLoansParams struct {
	Column1   interface{} `json:"column_1"`
	FINDINSET string      `json:"FIND_IN_SET"`
	ClientID  uint32      `json:"client_id"`
}

func (q *Queries) CountClientLoans(ctx context.Context, arg CountClientLoansParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countClientLoans, arg.Column1, arg.FINDINSET, arg.ClientID)
	var total_loans int64
	err := row.Scan(&total_loans)
	return total_loans, err
}

const countExpectedPayments = `-- name: CountExpectedPayments :one
SELECT COUNT(*) AS total_unexpected
FROM clients c
JOIN loans l ON l.client_id = c.id AND l.status = 'ACTIVE'
JOIN products p ON l.product_id = p.id
JOIN users u ON l.loan_officer = u.id
JOIN branches b ON u.branch_id = b.id
WHERE 
    (
        COALESCE(?, '') = '' 
        OR LOWER(c.full_name) LIKE ?
        OR LOWER(u.full_name) LIKE ?
    )
`

type CountExpectedPaymentsParams struct {
	Column1    interface{} `json:"column_1"`
	FullName   string      `json:"full_name"`
	FullName_2 string      `json:"full_name_2"`
}

func (q *Queries) CountExpectedPayments(ctx context.Context, arg CountExpectedPaymentsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countExpectedPayments, arg.Column1, arg.FullName, arg.FullName_2)
	var total_unexpected int64
	err := row.Scan(&total_unexpected)
	return total_unexpected, err
}

const countLoans = `-- name: CountLoans :one
SELECT COUNT(*) AS total_loans 
FROM loans l
JOIN products p ON l.product_id = p.id
JOIN clients c ON l.client_id = c.id
JOIN users u ON l.loan_officer = u.id
WHERE 
    (
        COALESCE(?, '') = '' 
        OR LOWER(c.full_name) LIKE ?
        OR LOWER(u.full_name) LIKE ?
    )
    AND (
        COALESCE(?, '') = '' 
        OR FIND_IN_SET(l.status, ?) > 0
    )
`

type CountLoansParams struct {
	Column1    interface{} `json:"column_1"`
	FullName   string      `json:"full_name"`
	FullName_2 string      `json:"full_name_2"`
	Column4    interface{} `json:"column_4"`
	FINDINSET  string      `json:"FIND_IN_SET"`
}

func (q *Queries) CountLoans(ctx context.Context, arg CountLoansParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLoans,
		arg.Column1,
		arg.FullName,
		arg.FullName_2,
		arg.Column4,
		arg.FINDINSET,
	)
	var total_loans int64
	err := row.Scan(&total_loans)
	return total_loans, err
}

const createLoan = `-- name: CreateLoan :execresult
INSERT INTO loans (product_id, client_id, loan_officer, loan_purpose, due_date, approved_by, disbursed_on, disbursed_by, total_installments, installments_period, status, processing_fee, fee_paid, created_by) 
VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateLoanParams struct {
	ProductID          uint32         `json:"product_id"`
	ClientID           uint32         `json:"client_id"`
	LoanOfficer        uint32         `json:"loan_officer"`
	LoanPurpose        sql.NullString `json:"loan_purpose"`
	DueDate            sql.NullTime   `json:"due_date"`
	ApprovedBy         uint32         `json:"approved_by"`
	DisbursedOn        sql.NullTime   `json:"disbursed_on"`
	DisbursedBy        sql.NullInt32  `json:"disbursed_by"`
	TotalInstallments  uint32         `json:"total_installments"`
	InstallmentsPeriod uint32         `json:"installments_period"`
	Status             LoansStatus    `json:"status"`
	ProcessingFee      float64        `json:"processing_fee"`
	FeePaid            bool           `json:"fee_paid"`
	CreatedBy          uint32         `json:"created_by"`
}

func (q *Queries) CreateLoan(ctx context.Context, arg CreateLoanParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createLoan,
		arg.ProductID,
		arg.ClientID,
		arg.LoanOfficer,
		arg.LoanPurpose,
		arg.DueDate,
		arg.ApprovedBy,
		arg.DisbursedOn,
		arg.DisbursedBy,
		arg.TotalInstallments,
		arg.InstallmentsPeriod,
		arg.Status,
		arg.ProcessingFee,
		arg.FeePaid,
		arg.CreatedBy,
	)
}

const deleteLoan = `-- name: DeleteLoan :exec
DELETE FROM loans WHERE id = ?
`

func (q *Queries) DeleteLoan(ctx context.Context, id uint32) error {
	_, err := q.db.ExecContext(ctx, deleteLoan, id)
	return err
}

const disburseLoan = `-- name: DisburseLoan :execresult
UPDATE loans 
    SET disbursed_on = coalesce(?, disbursed_on),
    disbursed_by = ?,
    status = coalesce(?, status),
    due_date = coalesce(?, due_date),
    fee_paid =coalesce(?, fee_paid)
WHERE id = ?
`

type DisburseLoanParams struct {
	DisbursedOn sql.NullTime    `json:"disbursed_on"`
	DisbursedBy sql.NullInt32   `json:"disbursed_by"`
	Status      NullLoansStatus `json:"status"`
	DueDate     sql.NullTime    `json:"due_date"`
	FeePaid     sql.NullBool    `json:"fee_paid"`
	ID          uint32          `json:"id"`
}

func (q *Queries) DisburseLoan(ctx context.Context, arg DisburseLoanParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, disburseLoan,
		arg.DisbursedOn,
		arg.DisbursedBy,
		arg.Status,
		arg.DueDate,
		arg.FeePaid,
		arg.ID,
	)
}

const getActiveLoanDetails = `-- name: GetActiveLoanDetails :one
SELECT 
    l.id,
    p.loan_amount,
    p.repay_amount,
    l.disbursed_on,
    l.due_date,
    l.paid_amount
FROM loans l
JOIN products p ON l.product_id = p.id
WHERE 
    l.client_id = ?
    AND l.status = 'ACTIVE'
LIMIT 1
`

type GetActiveLoanDetailsRow struct {
	ID          uint32       `json:"id"`
	LoanAmount  float64      `json:"loan_amount"`
	RepayAmount float64      `json:"repay_amount"`
	DisbursedOn sql.NullTime `json:"disbursed_on"`
	DueDate     sql.NullTime `json:"due_date"`
	PaidAmount  float64      `json:"paid_amount"`
}

func (q *Queries) GetActiveLoanDetails(ctx context.Context, clientID uint32) (GetActiveLoanDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getActiveLoanDetails, clientID)
	var i GetActiveLoanDetailsRow
	err := row.Scan(
		&i.ID,
		&i.LoanAmount,
		&i.RepayAmount,
		&i.DisbursedOn,
		&i.DueDate,
		&i.PaidAmount,
	)
	return i, err
}

const getClientActiveLoan = `-- name: GetClientActiveLoan :one
SELECT id FROM loans WHERE client_id = ? AND status = ? LIMIT 1
`

type GetClientActiveLoanParams struct {
	ClientID uint32      `json:"client_id"`
	Status   LoansStatus `json:"status"`
}

func (q *Queries) GetClientActiveLoan(ctx context.Context, arg GetClientActiveLoanParams) (uint32, error) {
	row := q.db.QueryRowContext(ctx, getClientActiveLoan, arg.ClientID, arg.Status)
	var id uint32
	err := row.Scan(&id)
	return id, err
}

const getClientLoans = `-- name: GetClientLoans :many
SELECT 
    l.id, l.product_id, l.client_id, l.loan_officer, l.loan_purpose, l.due_date, l.approved_by, l.disbursed_on, l.disbursed_by, l.total_installments, l.installments_period, l.status, l.processing_fee, l.paid_amount, l.updated_by, l.created_by, l.created_at, l.fee_paid, 

    -- Product Details
    p.branch_id AS product_branch_id,
    pb.name AS product_branch_name,  -- Fetch the product branch name
    p.loan_amount, 
    p.repay_amount, 
    p.interest_amount,

    -- Client Details
    c.full_name AS client_name,
    c.phone_number AS client_phone,
    c.active AS client_active,
    c.branch_id AS client_branch_id,
    cb.name AS client_branch_name,

    -- Loan Officer Details
    u.full_name AS loan_officer_name,
    u.email AS loan_officer_email,
    u.phone_number AS loan_officer_phone,

    -- Approved By Details
    a.full_name AS approved_by_name,
    a.email AS approved_by_email,
    a.phone_number AS approved_by_phone,

    -- Disbursed By Details (Nullable)
    d.full_name AS disbursed_by_name,
    d.email AS disbursed_by_email,
    d.phone_number AS disbursed_by_phone,

    -- Updated By Details (Nullable)
    up.full_name AS updated_by_name,
    up.email AS updated_by_email,
    up.phone_number AS updated_by_phone,

    -- Created By Details
    cr.full_name AS created_by_name,
    cr.email AS created_by_email,
    cr.phone_number AS created_by_phone

FROM loans l
JOIN products p ON l.product_id = p.id
JOIN branches pb ON p.branch_id = pb.id  -- Fetching product branch name
JOIN clients c ON l.client_id = c.id
JOIN branches cb ON c.branch_id = cb.id
JOIN users u ON l.loan_officer = u.id
JOIN users a ON l.approved_by = a.id

LEFT JOIN users d ON l.disbursed_by = d.id
LEFT JOIN users up ON l.updated_by = up.id
LEFT JOIN users cr ON l.created_by = cr.id

WHERE 
    (
        COALESCE(?, '') = '' 
        OR FIND_IN_SET(l.status, ?) > 0
    ) AND l.client_id = ?
ORDER BY l.created_at DESC
LIMIT ? OFFSET ?
`

type GetClientLoansParams struct {
	Column1   interface{} `json:"column_1"`
	FINDINSET string      `json:"FIND_IN_SET"`
	ClientID  uint32      `json:"client_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type GetClientLoansRow struct {
	ID                 uint32         `json:"id"`
	ProductID          uint32         `json:"product_id"`
	ClientID           uint32         `json:"client_id"`
	LoanOfficer        uint32         `json:"loan_officer"`
	LoanPurpose        sql.NullString `json:"loan_purpose"`
	DueDate            sql.NullTime   `json:"due_date"`
	ApprovedBy         uint32         `json:"approved_by"`
	DisbursedOn        sql.NullTime   `json:"disbursed_on"`
	DisbursedBy        sql.NullInt32  `json:"disbursed_by"`
	TotalInstallments  uint32         `json:"total_installments"`
	InstallmentsPeriod uint32         `json:"installments_period"`
	Status             LoansStatus    `json:"status"`
	ProcessingFee      float64        `json:"processing_fee"`
	PaidAmount         float64        `json:"paid_amount"`
	UpdatedBy          sql.NullInt32  `json:"updated_by"`
	CreatedBy          uint32         `json:"created_by"`
	CreatedAt          time.Time      `json:"created_at"`
	FeePaid            bool           `json:"fee_paid"`
	ProductBranchID    uint32         `json:"product_branch_id"`
	ProductBranchName  string         `json:"product_branch_name"`
	LoanAmount         float64        `json:"loan_amount"`
	RepayAmount        float64        `json:"repay_amount"`
	InterestAmount     float64        `json:"interest_amount"`
	ClientName         string         `json:"client_name"`
	ClientPhone        string         `json:"client_phone"`
	ClientActive       bool           `json:"client_active"`
	ClientBranchID     uint32         `json:"client_branch_id"`
	ClientBranchName   string         `json:"client_branch_name"`
	LoanOfficerName    string         `json:"loan_officer_name"`
	LoanOfficerEmail   string         `json:"loan_officer_email"`
	LoanOfficerPhone   string         `json:"loan_officer_phone"`
	ApprovedByName     string         `json:"approved_by_name"`
	ApprovedByEmail    string         `json:"approved_by_email"`
	ApprovedByPhone    string         `json:"approved_by_phone"`
	DisbursedByName    sql.NullString `json:"disbursed_by_name"`
	DisbursedByEmail   sql.NullString `json:"disbursed_by_email"`
	DisbursedByPhone   sql.NullString `json:"disbursed_by_phone"`
	UpdatedByName      sql.NullString `json:"updated_by_name"`
	UpdatedByEmail     sql.NullString `json:"updated_by_email"`
	UpdatedByPhone     sql.NullString `json:"updated_by_phone"`
	CreatedByName      sql.NullString `json:"created_by_name"`
	CreatedByEmail     sql.NullString `json:"created_by_email"`
	CreatedByPhone     sql.NullString `json:"created_by_phone"`
}

// Left joins for optional fields (disbursed_by, updated_by, created_by)
func (q *Queries) GetClientLoans(ctx context.Context, arg GetClientLoansParams) ([]GetClientLoansRow, error) {
	rows, err := q.db.QueryContext(ctx, getClientLoans,
		arg.Column1,
		arg.FINDINSET,
		arg.ClientID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClientLoansRow{}
	for rows.Next() {
		var i GetClientLoansRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ClientID,
			&i.LoanOfficer,
			&i.LoanPurpose,
			&i.DueDate,
			&i.ApprovedBy,
			&i.DisbursedOn,
			&i.DisbursedBy,
			&i.TotalInstallments,
			&i.InstallmentsPeriod,
			&i.Status,
			&i.ProcessingFee,
			&i.PaidAmount,
			&i.UpdatedBy,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.FeePaid,
			&i.ProductBranchID,
			&i.ProductBranchName,
			&i.LoanAmount,
			&i.RepayAmount,
			&i.InterestAmount,
			&i.ClientName,
			&i.ClientPhone,
			&i.ClientActive,
			&i.ClientBranchID,
			&i.ClientBranchName,
			&i.LoanOfficerName,
			&i.LoanOfficerEmail,
			&i.LoanOfficerPhone,
			&i.ApprovedByName,
			&i.ApprovedByEmail,
			&i.ApprovedByPhone,
			&i.DisbursedByName,
			&i.DisbursedByEmail,
			&i.DisbursedByPhone,
			&i.UpdatedByName,
			&i.UpdatedByEmail,
			&i.UpdatedByPhone,
			&i.CreatedByName,
			&i.CreatedByEmail,
			&i.CreatedByPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoan = `-- name: GetLoan :one
SELECT id, product_id, client_id, loan_officer, loan_purpose, due_date, approved_by, disbursed_on, disbursed_by, total_installments, installments_period, status, processing_fee, paid_amount, updated_by, created_by, created_at, fee_paid FROM loans WHERE id = ? LIMIT 1
`

func (q *Queries) GetLoan(ctx context.Context, id uint32) (Loan, error) {
	row := q.db.QueryRowContext(ctx, getLoan, id)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ClientID,
		&i.LoanOfficer,
		&i.LoanPurpose,
		&i.DueDate,
		&i.ApprovedBy,
		&i.DisbursedOn,
		&i.DisbursedBy,
		&i.TotalInstallments,
		&i.InstallmentsPeriod,
		&i.Status,
		&i.ProcessingFee,
		&i.PaidAmount,
		&i.UpdatedBy,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.FeePaid,
	)
	return i, err
}

const getLoanClientID = `-- name: GetLoanClientID :one
SELECT 
    client_id
FROM loans 
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetLoanClientID(ctx context.Context, id uint32) (uint32, error) {
	row := q.db.QueryRowContext(ctx, getLoanClientID, id)
	var client_id uint32
	err := row.Scan(&client_id)
	return client_id, err
}

const getLoanData = `-- name: GetLoanData :many
SELECT id FROM loans
`

func (q *Queries) GetLoanData(ctx context.Context) ([]uint32, error) {
	rows, err := q.db.QueryContext(ctx, getLoanData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uint32{}
	for rows.Next() {
		var id uint32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoanDetails = `-- name: GetLoanDetails :one
SELECT 
    l.id,
    l.client_id,
    p.loan_amount,
    p.repay_amount,
    l.disbursed_on,
    l.due_date,
    l.paid_amount,
    l.status
FROM loans l
JOIN products p ON l.product_id = p.id
WHERE 
    l.id = ?
LIMIT 1
`

type GetLoanDetailsRow struct {
	ID          uint32       `json:"id"`
	ClientID    uint32       `json:"client_id"`
	LoanAmount  float64      `json:"loan_amount"`
	RepayAmount float64      `json:"repay_amount"`
	DisbursedOn sql.NullTime `json:"disbursed_on"`
	DueDate     sql.NullTime `json:"due_date"`
	PaidAmount  float64      `json:"paid_amount"`
	Status      LoansStatus  `json:"status"`
}

func (q *Queries) GetLoanDetails(ctx context.Context, id uint32) (GetLoanDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getLoanDetails, id)
	var i GetLoanDetailsRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.LoanAmount,
		&i.RepayAmount,
		&i.DisbursedOn,
		&i.DueDate,
		&i.PaidAmount,
		&i.Status,
	)
	return i, err
}

const getLoanEvents = `-- name: GetLoanEvents :many
SELECT 
    l.id AS loan_id,
    l.disbursed_on AS disbursed_date,
    CASE 
        WHEN l.status = 'ACTIVE' THEN l.due_date
        ELSE NULL
    END AS due_date,

    c.full_name AS client_name,
    p.loan_amount AS loan_amount,
    CASE 
        WHEN l.status = 'ACTIVE' THEN (p.repay_amount - l.paid_amount)
        ELSE NULL
    END AS payment_due

FROM loans l
JOIN clients c ON l.client_id = c.id
JOIN products p ON l.product_id = p.id
WHERE l.disbursed_on IS NOT NULL 
ORDER BY l.disbursed_on DESC
`

type GetLoanEventsRow struct {
	LoanID        uint32       `json:"loan_id"`
	DisbursedDate sql.NullTime `json:"disbursed_date"`
	DueDate       string       `json:"due_date"`
	ClientName    string       `json:"client_name"`
	LoanAmount    float64      `json:"loan_amount"`
	PaymentDue    string       `json:"payment_due"`
}

func (q *Queries) GetLoanEvents(ctx context.Context) ([]GetLoanEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLoanEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLoanEventsRow{}
	for rows.Next() {
		var i GetLoanEventsRow
		if err := rows.Scan(
			&i.LoanID,
			&i.DisbursedDate,
			&i.DueDate,
			&i.ClientName,
			&i.LoanAmount,
			&i.PaymentDue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoanFullData = `-- name: GetLoanFullData :one
SELECT 
    l.id, l.product_id, l.client_id, l.loan_officer, l.loan_purpose, l.due_date, l.approved_by, l.disbursed_on, l.disbursed_by, l.total_installments, l.installments_period, l.status, l.processing_fee, l.paid_amount, l.updated_by, l.created_by, l.created_at, l.fee_paid, 

    -- Product Details
    pb.name AS product_branch_name,  -- Fetch the product branch name
    p.loan_amount, 
    p.repay_amount, 
    p.interest_amount,

    -- Client Details
    c.full_name AS client_name,
    c.phone_number AS client_phone,
    c.active AS client_active,
    c.branch_id AS client_branch_id,
    cb.name AS client_branch_name,

    -- Loan Officer Details
    u.full_name AS loan_officer_name,
    u.email AS loan_officer_email,
    u.phone_number AS loan_officer_phone,

    -- Approved By
    a.full_name AS approved_by_name,
    a.email AS approved_by_email,
    a.phone_number AS approved_by_phone,

    -- Disbursed By (optional)
    d.full_name AS disbursed_by_name,
    d.email AS disbursed_by_email,
    d.phone_number AS disbursed_by_phone,

    -- Updated By (optional)
    up.full_name AS updated_by_name,
    up.email AS updated_by_email,
    up.phone_number AS updated_by_phone,

    -- Created By
    cr.full_name AS created_by_name,
    cr.email AS created_by_email,
    cr.phone_number AS created_by_phone

FROM loans l
JOIN products p ON l.product_id = p.id
JOIN branches pb ON p.branch_id = pb.id  -- Fetching product branch name
JOIN clients c ON l.client_id = c.id
JOIN branches cb ON c.branch_id = cb.id
JOIN users u ON l.loan_officer = u.id
JOIN users a ON l.approved_by = a.id

LEFT JOIN users d ON l.disbursed_by = d.id
LEFT JOIN users up ON l.updated_by = up.id
LEFT JOIN users cr ON l.created_by = cr.id

WHERE l.id = ?
LIMIT 1
`

type GetLoanFullDataRow struct {
	ID                 uint32         `json:"id"`
	ProductID          uint32         `json:"product_id"`
	ClientID           uint32         `json:"client_id"`
	LoanOfficer        uint32         `json:"loan_officer"`
	LoanPurpose        sql.NullString `json:"loan_purpose"`
	DueDate            sql.NullTime   `json:"due_date"`
	ApprovedBy         uint32         `json:"approved_by"`
	DisbursedOn        sql.NullTime   `json:"disbursed_on"`
	DisbursedBy        sql.NullInt32  `json:"disbursed_by"`
	TotalInstallments  uint32         `json:"total_installments"`
	InstallmentsPeriod uint32         `json:"installments_period"`
	Status             LoansStatus    `json:"status"`
	ProcessingFee      float64        `json:"processing_fee"`
	PaidAmount         float64        `json:"paid_amount"`
	UpdatedBy          sql.NullInt32  `json:"updated_by"`
	CreatedBy          uint32         `json:"created_by"`
	CreatedAt          time.Time      `json:"created_at"`
	FeePaid            bool           `json:"fee_paid"`
	ProductBranchName  string         `json:"product_branch_name"`
	LoanAmount         float64        `json:"loan_amount"`
	RepayAmount        float64        `json:"repay_amount"`
	InterestAmount     float64        `json:"interest_amount"`
	ClientName         string         `json:"client_name"`
	ClientPhone        string         `json:"client_phone"`
	ClientActive       bool           `json:"client_active"`
	ClientBranchID     uint32         `json:"client_branch_id"`
	ClientBranchName   string         `json:"client_branch_name"`
	LoanOfficerName    string         `json:"loan_officer_name"`
	LoanOfficerEmail   string         `json:"loan_officer_email"`
	LoanOfficerPhone   string         `json:"loan_officer_phone"`
	ApprovedByName     string         `json:"approved_by_name"`
	ApprovedByEmail    string         `json:"approved_by_email"`
	ApprovedByPhone    string         `json:"approved_by_phone"`
	DisbursedByName    sql.NullString `json:"disbursed_by_name"`
	DisbursedByEmail   sql.NullString `json:"disbursed_by_email"`
	DisbursedByPhone   sql.NullString `json:"disbursed_by_phone"`
	UpdatedByName      sql.NullString `json:"updated_by_name"`
	UpdatedByEmail     sql.NullString `json:"updated_by_email"`
	UpdatedByPhone     sql.NullString `json:"updated_by_phone"`
	CreatedByName      sql.NullString `json:"created_by_name"`
	CreatedByEmail     sql.NullString `json:"created_by_email"`
	CreatedByPhone     sql.NullString `json:"created_by_phone"`
}

// Left joins for optional fields (disbursed_by, updated_by, created_by)
func (q *Queries) GetLoanFullData(ctx context.Context, id uint32) (GetLoanFullDataRow, error) {
	row := q.db.QueryRowContext(ctx, getLoanFullData, id)
	var i GetLoanFullDataRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ClientID,
		&i.LoanOfficer,
		&i.LoanPurpose,
		&i.DueDate,
		&i.ApprovedBy,
		&i.DisbursedOn,
		&i.DisbursedBy,
		&i.TotalInstallments,
		&i.InstallmentsPeriod,
		&i.Status,
		&i.ProcessingFee,
		&i.PaidAmount,
		&i.UpdatedBy,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.FeePaid,
		&i.ProductBranchName,
		&i.LoanAmount,
		&i.RepayAmount,
		&i.InterestAmount,
		&i.ClientName,
		&i.ClientPhone,
		&i.ClientActive,
		&i.ClientBranchID,
		&i.ClientBranchName,
		&i.LoanOfficerName,
		&i.LoanOfficerEmail,
		&i.LoanOfficerPhone,
		&i.ApprovedByName,
		&i.ApprovedByEmail,
		&i.ApprovedByPhone,
		&i.DisbursedByName,
		&i.DisbursedByEmail,
		&i.DisbursedByPhone,
		&i.UpdatedByName,
		&i.UpdatedByEmail,
		&i.UpdatedByPhone,
		&i.CreatedByName,
		&i.CreatedByEmail,
		&i.CreatedByPhone,
	)
	return i, err
}

const getLoanStatus = `-- name: GetLoanStatus :one
SELECT status FROM loans WHERE id = ? LIMIT 1
`

func (q *Queries) GetLoanStatus(ctx context.Context, id uint32) (LoansStatus, error) {
	row := q.db.QueryRowContext(ctx, getLoanStatus, id)
	var status LoansStatus
	err := row.Scan(&status)
	return status, err
}

const listExpectedPayments = `-- name: ListExpectedPayments :many
SELECT 
	b.name AS branch_name,
	c.full_name AS client_name,
	u.full_name AS loan_officer_name,
	l.id AS loan_id, 
	p.loan_amount,
	p.repay_amount,
	COALESCE(p.repay_amount - l.paid_amount, 0) AS total_unpaid, 
	l.due_date
FROM clients c
JOIN loans l ON l.client_id = c.id AND l.status = 'ACTIVE'
JOIN products p ON l.product_id = p.id
JOIN users u ON l.loan_officer = u.id
JOIN branches b ON u.branch_id = b.id
WHERE 
    (
        COALESCE(?, '') = '' 
        OR LOWER(c.full_name) LIKE ?
        OR LOWER(u.full_name) LIKE ?
    )
ORDER BY l.due_date DESC
LIMIT ? OFFSET ?
`

type ListExpectedPaymentsParams struct {
	Column1    interface{} `json:"column_1"`
	FullName   string      `json:"full_name"`
	FullName_2 string      `json:"full_name_2"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type ListExpectedPaymentsRow struct {
	BranchName      string       `json:"branch_name"`
	ClientName      string       `json:"client_name"`
	LoanOfficerName string       `json:"loan_officer_name"`
	LoanID          uint32       `json:"loan_id"`
	LoanAmount      float64      `json:"loan_amount"`
	RepayAmount     float64      `json:"repay_amount"`
	TotalUnpaid     interface{}  `json:"total_unpaid"`
	DueDate         sql.NullTime `json:"due_date"`
}

func (q *Queries) ListExpectedPayments(ctx context.Context, arg ListExpectedPaymentsParams) ([]ListExpectedPaymentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listExpectedPayments,
		arg.Column1,
		arg.FullName,
		arg.FullName_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExpectedPaymentsRow{}
	for rows.Next() {
		var i ListExpectedPaymentsRow
		if err := rows.Scan(
			&i.BranchName,
			&i.ClientName,
			&i.LoanOfficerName,
			&i.LoanID,
			&i.LoanAmount,
			&i.RepayAmount,
			&i.TotalUnpaid,
			&i.DueDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoans = `-- name: ListLoans :many
SELECT 
    l.id, l.product_id, l.client_id, l.loan_officer, l.loan_purpose, l.due_date, l.approved_by, l.disbursed_on, l.disbursed_by, l.total_installments, l.installments_period, l.status, l.processing_fee, l.paid_amount, l.updated_by, l.created_by, l.created_at, l.fee_paid, 

    -- Product Details
    p.branch_id AS product_branch_id,
    pb.name AS product_branch_name,  -- Fetch the product branch name
    p.loan_amount, 
    p.repay_amount, 
    p.interest_amount,

    -- Client Details
    c.full_name AS client_name,
    c.phone_number AS client_phone,
    c.active AS client_active,
    c.branch_id AS client_branch_id,
    cb.name AS client_branch_name,

    -- Loan Officer Details
    u.full_name AS loan_officer_name,
    u.email AS loan_officer_email,
    u.phone_number AS loan_officer_phone,

    -- Approved By Details
    a.full_name AS approved_by_name,
    a.email AS approved_by_email,
    a.phone_number AS approved_by_phone,

    -- Disbursed By Details (Nullable)
    d.full_name AS disbursed_by_name,
    d.email AS disbursed_by_email,
    d.phone_number AS disbursed_by_phone,

    -- Updated By Details (Nullable)
    up.full_name AS updated_by_name,
    up.email AS updated_by_email,
    up.phone_number AS updated_by_phone,

    -- Created By Details
    cr.full_name AS created_by_name,
    cr.email AS created_by_email,
    cr.phone_number AS created_by_phone

FROM loans l
JOIN products p ON l.product_id = p.id
JOIN branches pb ON p.branch_id = pb.id  -- Fetching product branch name
JOIN clients c ON l.client_id = c.id
JOIN branches cb ON c.branch_id = cb.id
JOIN users u ON l.loan_officer = u.id
JOIN users a ON l.approved_by = a.id

LEFT JOIN users d ON l.disbursed_by = d.id
LEFT JOIN users up ON l.updated_by = up.id
LEFT JOIN users cr ON l.created_by = cr.id

WHERE 
    (
        COALESCE(?, '') = '' 
        OR LOWER(c.full_name) LIKE ?
        OR LOWER(u.full_name) LIKE ?
    )
    AND (
        COALESCE(?, '') = '' 
        OR FIND_IN_SET(l.status, ?) > 0
    )
ORDER BY l.created_at DESC
LIMIT ? OFFSET ?
`

type ListLoansParams struct {
	Column1    interface{} `json:"column_1"`
	FullName   string      `json:"full_name"`
	FullName_2 string      `json:"full_name_2"`
	Column4    interface{} `json:"column_4"`
	FINDINSET  string      `json:"FIND_IN_SET"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type ListLoansRow struct {
	ID                 uint32         `json:"id"`
	ProductID          uint32         `json:"product_id"`
	ClientID           uint32         `json:"client_id"`
	LoanOfficer        uint32         `json:"loan_officer"`
	LoanPurpose        sql.NullString `json:"loan_purpose"`
	DueDate            sql.NullTime   `json:"due_date"`
	ApprovedBy         uint32         `json:"approved_by"`
	DisbursedOn        sql.NullTime   `json:"disbursed_on"`
	DisbursedBy        sql.NullInt32  `json:"disbursed_by"`
	TotalInstallments  uint32         `json:"total_installments"`
	InstallmentsPeriod uint32         `json:"installments_period"`
	Status             LoansStatus    `json:"status"`
	ProcessingFee      float64        `json:"processing_fee"`
	PaidAmount         float64        `json:"paid_amount"`
	UpdatedBy          sql.NullInt32  `json:"updated_by"`
	CreatedBy          uint32         `json:"created_by"`
	CreatedAt          time.Time      `json:"created_at"`
	FeePaid            bool           `json:"fee_paid"`
	ProductBranchID    uint32         `json:"product_branch_id"`
	ProductBranchName  string         `json:"product_branch_name"`
	LoanAmount         float64        `json:"loan_amount"`
	RepayAmount        float64        `json:"repay_amount"`
	InterestAmount     float64        `json:"interest_amount"`
	ClientName         string         `json:"client_name"`
	ClientPhone        string         `json:"client_phone"`
	ClientActive       bool           `json:"client_active"`
	ClientBranchID     uint32         `json:"client_branch_id"`
	ClientBranchName   string         `json:"client_branch_name"`
	LoanOfficerName    string         `json:"loan_officer_name"`
	LoanOfficerEmail   string         `json:"loan_officer_email"`
	LoanOfficerPhone   string         `json:"loan_officer_phone"`
	ApprovedByName     string         `json:"approved_by_name"`
	ApprovedByEmail    string         `json:"approved_by_email"`
	ApprovedByPhone    string         `json:"approved_by_phone"`
	DisbursedByName    sql.NullString `json:"disbursed_by_name"`
	DisbursedByEmail   sql.NullString `json:"disbursed_by_email"`
	DisbursedByPhone   sql.NullString `json:"disbursed_by_phone"`
	UpdatedByName      sql.NullString `json:"updated_by_name"`
	UpdatedByEmail     sql.NullString `json:"updated_by_email"`
	UpdatedByPhone     sql.NullString `json:"updated_by_phone"`
	CreatedByName      sql.NullString `json:"created_by_name"`
	CreatedByEmail     sql.NullString `json:"created_by_email"`
	CreatedByPhone     sql.NullString `json:"created_by_phone"`
}

// Left joins for optional fields (disbursed_by, updated_by, created_by)
func (q *Queries) ListLoans(ctx context.Context, arg ListLoansParams) ([]ListLoansRow, error) {
	rows, err := q.db.QueryContext(ctx, listLoans,
		arg.Column1,
		arg.FullName,
		arg.FullName_2,
		arg.Column4,
		arg.FINDINSET,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLoansRow{}
	for rows.Next() {
		var i ListLoansRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ClientID,
			&i.LoanOfficer,
			&i.LoanPurpose,
			&i.DueDate,
			&i.ApprovedBy,
			&i.DisbursedOn,
			&i.DisbursedBy,
			&i.TotalInstallments,
			&i.InstallmentsPeriod,
			&i.Status,
			&i.ProcessingFee,
			&i.PaidAmount,
			&i.UpdatedBy,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.FeePaid,
			&i.ProductBranchID,
			&i.ProductBranchName,
			&i.LoanAmount,
			&i.RepayAmount,
			&i.InterestAmount,
			&i.ClientName,
			&i.ClientPhone,
			&i.ClientActive,
			&i.ClientBranchID,
			&i.ClientBranchName,
			&i.LoanOfficerName,
			&i.LoanOfficerEmail,
			&i.LoanOfficerPhone,
			&i.ApprovedByName,
			&i.ApprovedByEmail,
			&i.ApprovedByPhone,
			&i.DisbursedByName,
			&i.DisbursedByEmail,
			&i.DisbursedByPhone,
			&i.UpdatedByName,
			&i.UpdatedByEmail,
			&i.UpdatedByPhone,
			&i.CreatedByName,
			&i.CreatedByEmail,
			&i.CreatedByPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByClient = `-- name: ListLoansByClient :many
SELECT id, product_id, client_id, loan_officer, loan_purpose, due_date, approved_by, disbursed_on, disbursed_by, total_installments, installments_period, status, processing_fee, paid_amount, updated_by, created_by, created_at, fee_paid FROM loans WHERE client_id = ? LIMIT ? OFFSET ?
`

type ListLoansByClientParams struct {
	ClientID uint32 `json:"client_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) ListLoansByClient(ctx context.Context, arg ListLoansByClientParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listLoansByClient, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Loan{}
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ClientID,
			&i.LoanOfficer,
			&i.LoanPurpose,
			&i.DueDate,
			&i.ApprovedBy,
			&i.DisbursedOn,
			&i.DisbursedBy,
			&i.TotalInstallments,
			&i.InstallmentsPeriod,
			&i.Status,
			&i.ProcessingFee,
			&i.PaidAmount,
			&i.UpdatedBy,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.FeePaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByLoanOfficer = `-- name: ListLoansByLoanOfficer :many
SELECT id, product_id, client_id, loan_officer, loan_purpose, due_date, approved_by, disbursed_on, disbursed_by, total_installments, installments_period, status, processing_fee, paid_amount, updated_by, created_by, created_at, fee_paid FROM loans WHERE loan_officer = ? LIMIT ? OFFSET ?
`

type ListLoansByLoanOfficerParams struct {
	LoanOfficer uint32 `json:"loan_officer"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) ListLoansByLoanOfficer(ctx context.Context, arg ListLoansByLoanOfficerParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listLoansByLoanOfficer, arg.LoanOfficer, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Loan{}
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ClientID,
			&i.LoanOfficer,
			&i.LoanPurpose,
			&i.DueDate,
			&i.ApprovedBy,
			&i.DisbursedOn,
			&i.DisbursedBy,
			&i.TotalInstallments,
			&i.InstallmentsPeriod,
			&i.Status,
			&i.ProcessingFee,
			&i.PaidAmount,
			&i.UpdatedBy,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.FeePaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoansByStatus = `-- name: ListLoansByStatus :many
SELECT id, product_id, client_id, loan_officer, loan_purpose, due_date, approved_by, disbursed_on, disbursed_by, total_installments, installments_period, status, processing_fee, paid_amount, updated_by, created_by, created_at, fee_paid FROM loans WHERE status = ? LIMIT ? OFFSET ?
`

type ListLoansByStatusParams struct {
	Status LoansStatus `json:"status"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListLoansByStatus(ctx context.Context, arg ListLoansByStatusParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listLoansByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Loan{}
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ClientID,
			&i.LoanOfficer,
			&i.LoanPurpose,
			&i.DueDate,
			&i.ApprovedBy,
			&i.DisbursedOn,
			&i.DisbursedBy,
			&i.TotalInstallments,
			&i.InstallmentsPeriod,
			&i.Status,
			&i.ProcessingFee,
			&i.PaidAmount,
			&i.UpdatedBy,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.FeePaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonDisbursedLoans = `-- name: ListNonDisbursedLoans :many
SELECT id, product_id, client_id, loan_officer, loan_purpose, due_date, approved_by, disbursed_on, disbursed_by, total_installments, installments_period, status, processing_fee, paid_amount, updated_by, created_by, created_at, fee_paid FROM loans WHERE disbursed_on IS NULL LIMIT ? OFFSET ?
`

type ListNonDisbursedLoansParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListNonDisbursedLoans(ctx context.Context, arg ListNonDisbursedLoansParams) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, listNonDisbursedLoans, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Loan{}
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ClientID,
			&i.LoanOfficer,
			&i.LoanPurpose,
			&i.DueDate,
			&i.ApprovedBy,
			&i.DisbursedOn,
			&i.DisbursedBy,
			&i.TotalInstallments,
			&i.InstallmentsPeriod,
			&i.Status,
			&i.ProcessingFee,
			&i.PaidAmount,
			&i.UpdatedBy,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.FeePaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reduceLoan = `-- name: ReduceLoan :execresult
UPDATE loans 
    SET paid_amount = paid_amount - ?,
    status = 'ACTIVE',
    updated_by = ?
WHERE id = ?
`

type ReduceLoanParams struct {
	PaidAmount float64       `json:"paid_amount"`
	UpdatedBy  sql.NullInt32 `json:"updated_by"`
	ID         uint32        `json:"id"`
}

func (q *Queries) ReduceLoan(ctx context.Context, arg ReduceLoanParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, reduceLoan, arg.PaidAmount, arg.UpdatedBy, arg.ID)
}

const transferLoan = `-- name: TransferLoan :execresult
UPDATE loans SET loan_officer = ?, updated_by = ? WHERE id = ?
`

type TransferLoanParams struct {
	LoanOfficer uint32        `json:"loan_officer"`
	UpdatedBy   sql.NullInt32 `json:"updated_by"`
	ID          uint32        `json:"id"`
}

func (q *Queries) TransferLoan(ctx context.Context, arg TransferLoanParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, transferLoan, arg.LoanOfficer, arg.UpdatedBy, arg.ID)
}

const updateLoan = `-- name: UpdateLoan :execresult
UPDATE loans 
    SET paid_amount = paid_amount + ?,
    updated_by = coalesce(?, updated_by)
WHERE id = ?
`

type UpdateLoanParams struct {
	PaidAmount float64       `json:"paid_amount"`
	UpdatedBy  sql.NullInt32 `json:"updated_by"`
	ID         uint32        `json:"id"`
}

func (q *Queries) UpdateLoan(ctx context.Context, arg UpdateLoanParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateLoan, arg.PaidAmount, arg.UpdatedBy, arg.ID)
}

const updateLoanProcessingFeeStatus = `-- name: UpdateLoanProcessingFeeStatus :execresult
UPDATE loans SET fee_paid = ? WHERE id = ?
`

type UpdateLoanProcessingFeeStatusParams struct {
	FeePaid bool   `json:"fee_paid"`
	ID      uint32 `json:"id"`
}

func (q *Queries) UpdateLoanProcessingFeeStatus(ctx context.Context, arg UpdateLoanProcessingFeeStatusParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateLoanProcessingFeeStatus, arg.FeePaid, arg.ID)
}

const updateLoanStatus = `-- name: UpdateLoanStatus :execresult
UPDATE loans SET status = ? WHERE id = ?
`

type UpdateLoanStatusParams struct {
	Status LoansStatus `json:"status"`
	ID     uint32      `json:"id"`
}

func (q *Queries) UpdateLoanStatus(ctx context.Context, arg UpdateLoanStatusParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateLoanStatus, arg.Status, arg.ID)
}
