// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const checkUserExistance = `-- name: CheckUserExistance :one
SELECT COUNT(*) AS user_count FROM users WHERE email = ? LIMIT 1
`

func (q *Queries) CheckUserExistance(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkUserExistance, email)
	var user_count int64
	err := row.Scan(&user_count)
	return user_count, err
}

const countUsersByCategory = `-- name: CountUsersByCategory :one
SELECT COUNT(*) AS total_loans
FROM users u
JOIN branches b ON u.branch_id = b.id
WHERE 
    (
        COALESCE(?, '') = '' 
        OR LOWER(u.full_name) LIKE ?
        OR LOWER(u.email) LIKE ?
    )
    AND (
        COALESCE(?, '') = '' 
        OR FIND_IN_SET(u.role, ?) > 0
    )
`

type CountUsersByCategoryParams struct {
	Column1   interface{} `json:"column_1"`
	FullName  string      `json:"full_name"`
	Email     string      `json:"email"`
	Column4   interface{} `json:"column_4"`
	FINDINSET string      `json:"FIND_IN_SET"`
}

func (q *Queries) CountUsersByCategory(ctx context.Context, arg CountUsersByCategoryParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsersByCategory,
		arg.Column1,
		arg.FullName,
		arg.Email,
		arg.Column4,
		arg.FINDINSET,
	)
	var total_loans int64
	err := row.Scan(&total_loans)
	return total_loans, err
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO users (full_name, phone_number, email, password, refresh_token, role, branch_id, updated_at, updated_by, created_by) 
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateUserParams struct {
	FullName     string    `json:"full_name"`
	PhoneNumber  string    `json:"phone_number"`
	Email        string    `json:"email"`
	Password     string    `json:"password"`
	RefreshToken string    `json:"refresh_token"`
	Role         UsersRole `json:"role"`
	BranchID     uint32    `json:"branch_id"`
	UpdatedAt    time.Time `json:"updated_at"`
	UpdatedBy    uint32    `json:"updated_by"`
	CreatedBy    uint32    `json:"created_by"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser,
		arg.FullName,
		arg.PhoneNumber,
		arg.Email,
		arg.Password,
		arg.RefreshToken,
		arg.Role,
		arg.BranchID,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.CreatedBy,
	)
}

const getUser = `-- name: GetUser :one
SELECT 
    u.id, u.full_name, u.phone_number, u.email, u.password, u.password_updated, u.refresh_token, u.role, u.branch_id, u.updated_by, u.updated_at, u.created_by, u.created_at, 
    b.name AS branch_name 
FROM users u
JOIN branches b ON u.branch_id = b.id
WHERE u.id = ? 
LIMIT 1
`

type GetUserRow struct {
	ID              uint32    `json:"id"`
	FullName        string    `json:"full_name"`
	PhoneNumber     string    `json:"phone_number"`
	Email           string    `json:"email"`
	Password        string    `json:"password"`
	PasswordUpdated uint32    `json:"password_updated"`
	RefreshToken    string    `json:"refresh_token"`
	Role            UsersRole `json:"role"`
	BranchID        uint32    `json:"branch_id"`
	UpdatedBy       uint32    `json:"updated_by"`
	UpdatedAt       time.Time `json:"updated_at"`
	CreatedBy       uint32    `json:"created_by"`
	CreatedAt       time.Time `json:"created_at"`
	BranchName      string    `json:"branch_name"`
}

func (q *Queries) GetUser(ctx context.Context, id uint32) (GetUserRow, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i GetUserRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.PhoneNumber,
		&i.Email,
		&i.Password,
		&i.PasswordUpdated,
		&i.RefreshToken,
		&i.Role,
		&i.BranchID,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.BranchName,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT 
    u.id, u.full_name, u.phone_number, u.email, u.password, u.password_updated, u.refresh_token, u.role, u.branch_id, u.updated_by, u.updated_at, u.created_by, u.created_at, 
    b.name AS branch_name 
FROM users u
JOIN branches b ON u.branch_id = b.id
WHERE u.email = ? 
LIMIT 1
`

type GetUserByEmailRow struct {
	ID              uint32    `json:"id"`
	FullName        string    `json:"full_name"`
	PhoneNumber     string    `json:"phone_number"`
	Email           string    `json:"email"`
	Password        string    `json:"password"`
	PasswordUpdated uint32    `json:"password_updated"`
	RefreshToken    string    `json:"refresh_token"`
	Role            UsersRole `json:"role"`
	BranchID        uint32    `json:"branch_id"`
	UpdatedBy       uint32    `json:"updated_by"`
	UpdatedAt       time.Time `json:"updated_at"`
	CreatedBy       uint32    `json:"created_by"`
	CreatedAt       time.Time `json:"created_at"`
	BranchName      string    `json:"branch_name"`
}

// SELECT * FROM users WHERE id = ? LIMIT 1;
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.PhoneNumber,
		&i.Email,
		&i.Password,
		&i.PasswordUpdated,
		&i.RefreshToken,
		&i.Role,
		&i.BranchID,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.BranchName,
	)
	return i, err
}

const helperUser = `-- name: HelperUser :many
SELECT id, full_name FROM users
`

type HelperUserRow struct {
	ID       uint32 `json:"id"`
	FullName string `json:"full_name"`
}

func (q *Queries) HelperUser(ctx context.Context) ([]HelperUserRow, error) {
	rows, err := q.db.QueryContext(ctx, helperUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HelperUserRow{}
	for rows.Next() {
		var i HelperUserRow
		if err := rows.Scan(&i.ID, &i.FullName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const helperUserById = `-- name: HelperUserById :one
SELECT full_name FROM users
WHERE id = ?
`

func (q *Queries) HelperUserById(ctx context.Context, id uint32) (string, error) {
	row := q.db.QueryRowContext(ctx, helperUserById, id)
	var full_name string
	err := row.Scan(&full_name)
	return full_name, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, full_name, phone_number, email, password, password_updated, refresh_token, role, branch_id, updated_by, updated_at, created_by, created_at FROM users ORDER BY full_name DESC LIMIT ? OFFSET ?
`

type ListUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.PhoneNumber,
			&i.Email,
			&i.Password,
			&i.PasswordUpdated,
			&i.RefreshToken,
			&i.Role,
			&i.BranchID,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByCategory = `-- name: ListUsersByCategory :many
SELECT 
    u.id, u.full_name, u.phone_number, u.email, u.password, u.password_updated, u.refresh_token, u.role, u.branch_id, u.updated_by, u.updated_at, u.created_by, u.created_at, 
    b.name AS branch_name
FROM users u
JOIN branches b ON u.branch_id = b.id
WHERE 
    (
        COALESCE(?, '') = '' 
        OR LOWER(u.full_name) LIKE ?
        OR LOWER(u.email) LIKE ?
    )
    AND (
        COALESCE(?, '') = '' 
        OR FIND_IN_SET(u.role, ?) > 0
    )
 ORDER BY u.created_at DESC
LIMIT ? OFFSET ?
`

type ListUsersByCategoryParams struct {
	Column1   interface{} `json:"column_1"`
	FullName  string      `json:"full_name"`
	Email     string      `json:"email"`
	Column4   interface{} `json:"column_4"`
	FINDINSET string      `json:"FIND_IN_SET"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type ListUsersByCategoryRow struct {
	ID              uint32    `json:"id"`
	FullName        string    `json:"full_name"`
	PhoneNumber     string    `json:"phone_number"`
	Email           string    `json:"email"`
	Password        string    `json:"password"`
	PasswordUpdated uint32    `json:"password_updated"`
	RefreshToken    string    `json:"refresh_token"`
	Role            UsersRole `json:"role"`
	BranchID        uint32    `json:"branch_id"`
	UpdatedBy       uint32    `json:"updated_by"`
	UpdatedAt       time.Time `json:"updated_at"`
	CreatedBy       uint32    `json:"created_by"`
	CreatedAt       time.Time `json:"created_at"`
	BranchName      string    `json:"branch_name"`
}

func (q *Queries) ListUsersByCategory(ctx context.Context, arg ListUsersByCategoryParams) ([]ListUsersByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersByCategory,
		arg.Column1,
		arg.FullName,
		arg.Email,
		arg.Column4,
		arg.FINDINSET,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersByCategoryRow{}
	for rows.Next() {
		var i ListUsersByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.PhoneNumber,
			&i.Email,
			&i.Password,
			&i.PasswordUpdated,
			&i.RefreshToken,
			&i.Role,
			&i.BranchID,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.BranchName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :execresult
UPDATE users 
    SET role = coalesce(?, role), 
    branch_id = coalesce(?, branch_id),
    password = coalesce(?, password),
    refresh_token = coalesce(?, refresh_token),
    updated_at = coalesce(?, updated_at), 
    updated_by = coalesce(?, updated_by) 
WHERE id = ?
`

type UpdateUserParams struct {
	Role         NullUsersRole  `json:"role"`
	BranchID     sql.NullInt32  `json:"branch_id"`
	Password     sql.NullString `json:"password"`
	RefreshToken sql.NullString `json:"refresh_token"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	UpdatedBy    sql.NullInt32  `json:"updated_by"`
	ID           uint32         `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateUser,
		arg.Role,
		arg.BranchID,
		arg.Password,
		arg.RefreshToken,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.ID,
	)
}

const updateUserPassword = `-- name: UpdateUserPassword :execresult
UPDATE users SET password = ?, password_updated = password_updated + 1 WHERE email = ?
`

type UpdateUserPasswordParams struct {
	Password string `json:"password"`
	Email    string `json:"email"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateUserPassword, arg.Password, arg.Email)
}
