// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package generated

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"time"
)

type ClientsGender string

const (
	ClientsGenderMALE   ClientsGender = "MALE"
	ClientsGenderFEMALE ClientsGender = "FEMALE"
)

func (e *ClientsGender) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ClientsGender(s)
	case string:
		*e = ClientsGender(s)
	default:
		return fmt.Errorf("unsupported scan type for ClientsGender: %T", src)
	}
	return nil
}

type NullClientsGender struct {
	ClientsGender ClientsGender `json:"clients_gender"`
	Valid         bool          `json:"valid"` // Valid is true if ClientsGender is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullClientsGender) Scan(value interface{}) error {
	if value == nil {
		ns.ClientsGender, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ClientsGender.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullClientsGender) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ClientsGender), nil
}

type LoansStatus string

const (
	LoansStatusINACTIVE  LoansStatus = "INACTIVE"
	LoansStatusACTIVE    LoansStatus = "ACTIVE"
	LoansStatusCOMPLETED LoansStatus = "COMPLETED"
	LoansStatusDEFAULTED LoansStatus = "DEFAULTED"
)

func (e *LoansStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LoansStatus(s)
	case string:
		*e = LoansStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for LoansStatus: %T", src)
	}
	return nil
}

type NullLoansStatus struct {
	LoansStatus LoansStatus `json:"loans_status"`
	Valid       bool        `json:"valid"` // Valid is true if LoansStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLoansStatus) Scan(value interface{}) error {
	if value == nil {
		ns.LoansStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LoansStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLoansStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LoansStatus), nil
}

type NonPostedTransactionSource string

const (
	NonPostedTransactionSourceMPESA    NonPostedTransactionSource = "MPESA"
	NonPostedTransactionSourceINTERNAL NonPostedTransactionSource = "INTERNAL"
)

func (e *NonPostedTransactionSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NonPostedTransactionSource(s)
	case string:
		*e = NonPostedTransactionSource(s)
	default:
		return fmt.Errorf("unsupported scan type for NonPostedTransactionSource: %T", src)
	}
	return nil
}

type NullNonPostedTransactionSource struct {
	NonPostedTransactionSource NonPostedTransactionSource `json:"non_posted_transaction_source"`
	Valid                      bool                       `json:"valid"` // Valid is true if NonPostedTransactionSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNonPostedTransactionSource) Scan(value interface{}) error {
	if value == nil {
		ns.NonPostedTransactionSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NonPostedTransactionSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNonPostedTransactionSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NonPostedTransactionSource), nil
}

type UsersRole string

const (
	UsersRoleADMIN UsersRole = "ADMIN"
	UsersRoleAGENT UsersRole = "AGENT"
)

func (e *UsersRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UsersRole(s)
	case string:
		*e = UsersRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UsersRole: %T", src)
	}
	return nil
}

type NullUsersRole struct {
	UsersRole UsersRole `json:"users_role"`
	Valid     bool      `json:"valid"` // Valid is true if UsersRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUsersRole) Scan(value interface{}) error {
	if value == nil {
		ns.UsersRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UsersRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUsersRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UsersRole), nil
}

type Branch struct {
	ID   uint32 `json:"id"`
	Name string `json:"name"`
}

type Client struct {
	ID            uint32         `json:"id"`
	FullName      string         `json:"full_name"`
	PhoneNumber   string         `json:"phone_number"`
	IDNumber      sql.NullString `json:"id_number"`
	Dob           sql.NullTime   `json:"dob"`
	Gender        ClientsGender  `json:"gender"`
	Active        bool           `json:"active"`
	BranchID      uint32         `json:"branch_id"`
	AssignedStaff uint32         `json:"assigned_staff"`
	Overpayment   float64        `json:"overpayment"`
	UpdatedBy     uint32         `json:"updated_by"`
	UpdatedAt     time.Time      `json:"updated_at"`
	CreatedBy     uint32         `json:"created_by"`
	CreatedAt     time.Time      `json:"created_at"`
}

type Installment struct {
	ID                uint32       `json:"id"`
	LoanID            uint32       `json:"loan_id"`
	InstallmentNumber uint32       `json:"installment_number"`
	AmountDue         float64      `json:"amount_due"`
	RemainingAmount   float64      `json:"remaining_amount"`
	Paid              bool         `json:"paid"`
	PaidAt            sql.NullTime `json:"paid_at"`
	DueDate           time.Time    `json:"due_date"`
}

type Loan struct {
	ID                 uint32         `json:"id"`
	ProductID          uint32         `json:"product_id"`
	ClientID           uint32         `json:"client_id"`
	LoanOfficer        uint32         `json:"loan_officer"`
	LoanPurpose        sql.NullString `json:"loan_purpose"`
	DueDate            sql.NullTime   `json:"due_date"`
	ApprovedBy         uint32         `json:"approved_by"`
	DisbursedOn        sql.NullTime   `json:"disbursed_on"`
	DisbursedBy        sql.NullInt32  `json:"disbursed_by"`
	TotalInstallments  uint32         `json:"total_installments"`
	InstallmentsPeriod uint32         `json:"installments_period"`
	Status             LoansStatus    `json:"status"`
	ProcessingFee      float64        `json:"processing_fee"`
	PaidAmount         float64        `json:"paid_amount"`
	UpdatedBy          sql.NullInt32  `json:"updated_by"`
	CreatedBy          uint32         `json:"created_by"`
	CreatedAt          time.Time      `json:"created_at"`
	FeePaid            bool           `json:"fee_paid"`
}

type NonPosted struct {
	ID                uint32                     `json:"id"`
	TransactionNumber string                     `json:"transaction_number"`
	AccountNumber     string                     `json:"account_number"`
	PhoneNumber       string                     `json:"phone_number"`
	PayingName        string                     `json:"paying_name"`
	Amount            float64                    `json:"amount"`
	AssignTo          sql.NullInt32              `json:"assign_to"`
	PaidDate          time.Time                  `json:"paid_date"`
	TransactionSource NonPostedTransactionSource `json:"transaction_source"`
	AssignedBy        string                     `json:"assigned_by"`
}

type Product struct {
	ID             uint32    `json:"id"`
	BranchID       uint32    `json:"branch_id"`
	LoanAmount     float64   `json:"loan_amount"`
	RepayAmount    float64   `json:"repay_amount"`
	InterestAmount float64   `json:"interest_amount"`
	UpdatedBy      uint32    `json:"updated_by"`
	UpdatedAt      time.Time `json:"updated_at"`
	CreatedAt      time.Time `json:"created_at"`
}

type User struct {
	ID              uint32    `json:"id"`
	FullName        string    `json:"full_name"`
	PhoneNumber     string    `json:"phone_number"`
	Email           string    `json:"email"`
	Password        string    `json:"password"`
	PasswordUpdated uint32    `json:"password_updated"`
	RefreshToken    string    `json:"refresh_token"`
	Role            UsersRole `json:"role"`
	BranchID        uint32    `json:"branch_id"`
	UpdatedBy       uint32    `json:"updated_by"`
	UpdatedAt       time.Time `json:"updated_at"`
	CreatedBy       uint32    `json:"created_by"`
	CreatedAt       time.Time `json:"created_at"`
}
