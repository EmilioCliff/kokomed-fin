// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: installments.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const createInstallment = `-- name: CreateInstallment :execresult
INSERT INTO installments (loan_id, installment_number, amount_due, remaining_amount, due_date) 
VALUES (
    ?, ?, ?, ?, ?
)
`

type CreateInstallmentParams struct {
	LoanID            uint32    `json:"loan_id"`
	InstallmentNumber uint32    `json:"installment_number"`
	AmountDue         float64   `json:"amount_due"`
	RemainingAmount   float64   `json:"remaining_amount"`
	DueDate           time.Time `json:"due_date"`
}

func (q *Queries) CreateInstallment(ctx context.Context, arg CreateInstallmentParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createInstallment,
		arg.LoanID,
		arg.InstallmentNumber,
		arg.AmountDue,
		arg.RemainingAmount,
		arg.DueDate,
	)
}

const getInstallment = `-- name: GetInstallment :one
SELECT id, loan_id, installment_number, amount_due, remaining_amount, paid, paid_at, due_date FROM installments WHERE id = ? LIMIT 1
`

func (q *Queries) GetInstallment(ctx context.Context, id uint32) (Installment, error) {
	row := q.db.QueryRowContext(ctx, getInstallment, id)
	var i Installment
	err := row.Scan(
		&i.ID,
		&i.LoanID,
		&i.InstallmentNumber,
		&i.AmountDue,
		&i.RemainingAmount,
		&i.Paid,
		&i.PaidAt,
		&i.DueDate,
	)
	return i, err
}

const listInstallmentsByLoan = `-- name: ListInstallmentsByLoan :many
SELECT id, loan_id, installment_number, amount_due, remaining_amount, paid, paid_at, due_date FROM installments WHERE loan_id = ? ORDER BY due_date ASC
`

func (q *Queries) ListInstallmentsByLoan(ctx context.Context, loanID uint32) ([]Installment, error) {
	rows, err := q.db.QueryContext(ctx, listInstallmentsByLoan, loanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Installment{}
	for rows.Next() {
		var i Installment
		if err := rows.Scan(
			&i.ID,
			&i.LoanID,
			&i.InstallmentNumber,
			&i.AmountDue,
			&i.RemainingAmount,
			&i.Paid,
			&i.PaidAt,
			&i.DueDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnpaidInstallmentsByLoan = `-- name: ListUnpaidInstallmentsByLoan :many
SELECT id, loan_id, installment_number, amount_due, remaining_amount, paid, paid_at, due_date FROM installments WHERE loan_id = ? AND remaining_amount > 0 ORDER BY due_date ASC
`

func (q *Queries) ListUnpaidInstallmentsByLoan(ctx context.Context, loanID uint32) ([]Installment, error) {
	rows, err := q.db.QueryContext(ctx, listUnpaidInstallmentsByLoan, loanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Installment{}
	for rows.Next() {
		var i Installment
		if err := rows.Scan(
			&i.ID,
			&i.LoanID,
			&i.InstallmentNumber,
			&i.AmountDue,
			&i.RemainingAmount,
			&i.Paid,
			&i.PaidAt,
			&i.DueDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const payInstallment = `-- name: PayInstallment :execresult
UPDATE installments 
    SET remaining_amount = ?,
    paid =  coalesce(?, paid),
    paid_at =  coalesce(?, paid_at)
WHERE id = ?
`

type PayInstallmentParams struct {
	RemainingAmount float64      `json:"remaining_amount"`
	Paid            sql.NullBool `json:"paid"`
	PaidAt          sql.NullTime `json:"paid_at"`
	ID              uint32       `json:"id"`
}

func (q *Queries) PayInstallment(ctx context.Context, arg PayInstallmentParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, payInstallment,
		arg.RemainingAmount,
		arg.Paid,
		arg.PaidAt,
		arg.ID,
	)
}

const updateInstallment = `-- name: UpdateInstallment :execresult
UPDATE installments 
    SET remaining_amount =  ?,
    paid =  coalesce(?, paid),
    paid_at =  coalesce(?, paid_at)
WHERE id = ?
`

type UpdateInstallmentParams struct {
	RemainingAmount float64      `json:"remaining_amount"`
	Paid            sql.NullBool `json:"paid"`
	PaidAt          sql.NullTime `json:"paid_at"`
	ID              uint32       `json:"id"`
}

func (q *Queries) UpdateInstallment(ctx context.Context, arg UpdateInstallmentParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateInstallment,
		arg.RemainingAmount,
		arg.Paid,
		arg.PaidAt,
		arg.ID,
	)
}
