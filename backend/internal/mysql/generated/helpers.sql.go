// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: helpers.sql

package generated

import (
	"context"
	"time"
)

const dashBoardDataHelper = `-- name: DashBoardDataHelper :one
SELECT
    -- Clients
    (SELECT COUNT(*) FROM clients) AS total_clients,
    (SELECT COUNT(*) FROM clients WHERE active = TRUE) AS active_clients,

    -- Loans
    (SELECT COUNT(*) FROM loans) AS total_loans,
    (SELECT COUNT(*) FROM loans WHERE status = 'ACTIVE') AS active_loans,
    (SELECT COUNT(*) FROM loans WHERE status = 'INACTIVE') AS inactive_loans,

     -- Financials
    (SELECT COALESCE(SUM(p.loan_amount), 0) 
     FROM loans l 
     JOIN products p ON l.product_id = p.id) AS total_loan_amount,

    (SELECT COALESCE(SUM(p.loan_amount), 0) 
     FROM loans l 
     JOIN products p ON l.product_id = p.id 
     WHERE l.status != 'INACTIVE') AS total_loan_disbursed,

    (SELECT COALESCE(SUM(p.loan_amount), 0) 
     FROM loans l 
     JOIN products p ON l.product_id = p.id 
     WHERE l.status = 'COMPLETED') AS total_loan_paid,

    -- Non-posted Payments
    (SELECT COALESCE(SUM(amount), 0) FROM non_posted) AS total_payments_received,
    (SELECT COALESCE(SUM(amount), 0) FROM non_posted WHERE assign_to IS NULL) AS total_non_posted
`

type DashBoardDataHelperRow struct {
	TotalClients          int64       `json:"total_clients"`
	ActiveClients         int64       `json:"active_clients"`
	TotalLoans            int64       `json:"total_loans"`
	ActiveLoans           int64       `json:"active_loans"`
	InactiveLoans         int64       `json:"inactive_loans"`
	TotalLoanAmount       interface{} `json:"total_loan_amount"`
	TotalLoanDisbursed    interface{} `json:"total_loan_disbursed"`
	TotalLoanPaid         interface{} `json:"total_loan_paid"`
	TotalPaymentsReceived interface{} `json:"total_payments_received"`
	TotalNonPosted        interface{} `json:"total_non_posted"`
}

func (q *Queries) DashBoardDataHelper(ctx context.Context) (DashBoardDataHelperRow, error) {
	row := q.db.QueryRowContext(ctx, dashBoardDataHelper)
	var i DashBoardDataHelperRow
	err := row.Scan(
		&i.TotalClients,
		&i.ActiveClients,
		&i.TotalLoans,
		&i.ActiveLoans,
		&i.InactiveLoans,
		&i.TotalLoanAmount,
		&i.TotalLoanDisbursed,
		&i.TotalLoanPaid,
		&i.TotalPaymentsReceived,
		&i.TotalNonPosted,
	)
	return i, err
}

const dashBoardInactiveLoans = `-- name: DashBoardInactiveLoans :many
SELECT l.id, p.loan_amount, u.full_name, u2.full_name, p.repay_amount, l.client_id, l.loan_officer, l.approved_by, l.created_at 
FROM loans l 
JOIN users u ON l.client_id = u.id
JOIN users u2 ON l.approved_by = u2.id
JOIN products p ON l.product_id = p.id WHERE l.status = 'INACTIVE'
ORDER BY l.created_at DESC LIMIT 10
`

type DashBoardInactiveLoansRow struct {
	ID          uint32    `json:"id"`
	LoanAmount  float64   `json:"loan_amount"`
	FullName    string    `json:"full_name"`
	FullName_2  string    `json:"full_name_2"`
	RepayAmount float64   `json:"repay_amount"`
	ClientID    uint32    `json:"client_id"`
	LoanOfficer uint32    `json:"loan_officer"`
	ApprovedBy  uint32    `json:"approved_by"`
	CreatedAt   time.Time `json:"created_at"`
}

func (q *Queries) DashBoardInactiveLoans(ctx context.Context) ([]DashBoardInactiveLoansRow, error) {
	rows, err := q.db.QueryContext(ctx, dashBoardInactiveLoans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DashBoardInactiveLoansRow{}
	for rows.Next() {
		var i DashBoardInactiveLoansRow
		if err := rows.Scan(
			&i.ID,
			&i.LoanAmount,
			&i.FullName,
			&i.FullName_2,
			&i.RepayAmount,
			&i.ClientID,
			&i.LoanOfficer,
			&i.ApprovedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dashBoardRecentsPayments = `-- name: DashBoardRecentsPayments :many
SELECT id, paying_name, amount, paid_date 
FROM non_posted 
WHERE paid_date >= NOW() - INTERVAL 15 DAY
ORDER BY paid_date DESC LIMIT 10
`

type DashBoardRecentsPaymentsRow struct {
	ID         uint32    `json:"id"`
	PayingName string    `json:"paying_name"`
	Amount     float64   `json:"amount"`
	PaidDate   time.Time `json:"paid_date"`
}

func (q *Queries) DashBoardRecentsPayments(ctx context.Context) ([]DashBoardRecentsPaymentsRow, error) {
	rows, err := q.db.QueryContext(ctx, dashBoardRecentsPayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DashBoardRecentsPaymentsRow{}
	for rows.Next() {
		var i DashBoardRecentsPaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.PayingName,
			&i.Amount,
			&i.PaidDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
