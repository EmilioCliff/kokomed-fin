// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: non_posted.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const assignNonPosted = `-- name: AssignNonPosted :execresult


UPDATE non_posted 
    SET assign_to = ?,
    transaction_source = ?,
    assigned_by = COALESCE(?, assigned_by)
WHERE id = ?
`

type AssignNonPostedParams struct {
	AssignTo          sql.NullInt32              `json:"assign_to"`
	TransactionSource NonPostedTransactionSource `json:"transaction_source"`
	AssignedBy        sql.NullString             `json:"assigned_by"`
	ID                uint32                     `json:"id"`
}

// SELECT * FROM non_posted WHERE id = ? LIMIT 1;
func (q *Queries) AssignNonPosted(ctx context.Context, arg AssignNonPostedParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, assignNonPosted,
		arg.AssignTo,
		arg.TransactionSource,
		arg.AssignedBy,
		arg.ID,
	)
}

const countClientsNonPosted = `-- name: CountClientsNonPosted :one
SELECT COUNT(*) AS total_non_posted 
FROM non_posted
WHERE 
    (
        (assign_to = ?)
        OR (account_number = ?)
    )
`

type CountClientsNonPostedParams struct {
	AssignTo      sql.NullInt32  `json:"assign_to"`
	AccountNumber sql.NullString `json:"account_number"`
}

func (q *Queries) CountClientsNonPosted(ctx context.Context, arg CountClientsNonPostedParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countClientsNonPosted, arg.AssignTo, arg.AccountNumber)
	var total_non_posted int64
	err := row.Scan(&total_non_posted)
	return total_non_posted, err
}

const countNonPostedByCategory = `-- name: CountNonPostedByCategory :one
SELECT COUNT(*) AS total_non_posted 
FROM non_posted
WHERE 
    (
        COALESCE(?, '') = '' 
        OR LOWER(paying_name) LIKE ?
        OR LOWER(account_number) LIKE ?
        OR LOWER(transaction_number) LIKE ?
    )
    AND (
        COALESCE(?, '') = '' 
        OR FIND_IN_SET(transaction_source, ?) > 0
    )
    AND paid_date BETWEEN ? AND ?
`

type CountNonPostedByCategoryParams struct {
	Column1           interface{} `json:"column_1"`
	PayingName        string      `json:"paying_name"`
	AccountNumber     string      `json:"account_number"`
	TransactionNumber string      `json:"transaction_number"`
	Column5           interface{} `json:"column_5"`
	FINDINSET         string      `json:"FIND_IN_SET"`
	FromPaidDate      time.Time   `json:"from_paid_date"`
	ToPaidDate        time.Time   `json:"to_paid_date"`
}

func (q *Queries) CountNonPostedByCategory(ctx context.Context, arg CountNonPostedByCategoryParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNonPostedByCategory,
		arg.Column1,
		arg.PayingName,
		arg.AccountNumber,
		arg.TransactionNumber,
		arg.Column5,
		arg.FINDINSET,
		arg.FromPaidDate,
		arg.ToPaidDate,
	)
	var total_non_posted int64
	err := row.Scan(&total_non_posted)
	return total_non_posted, err
}

const createNonPosted = `-- name: CreateNonPosted :execresult
INSERT INTO non_posted (transaction_source, transaction_number, account_number, phone_number, paying_name, amount, paid_date, assign_to, assigned_by) 
VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateNonPostedParams struct {
	TransactionSource NonPostedTransactionSource `json:"transaction_source"`
	TransactionNumber string                     `json:"transaction_number"`
	AccountNumber     string                     `json:"account_number"`
	PhoneNumber       string                     `json:"phone_number"`
	PayingName        string                     `json:"paying_name"`
	Amount            float64                    `json:"amount"`
	PaidDate          time.Time                  `json:"paid_date"`
	AssignTo          sql.NullInt32              `json:"assign_to"`
	AssignedBy        string                     `json:"assigned_by"`
}

func (q *Queries) CreateNonPosted(ctx context.Context, arg CreateNonPostedParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createNonPosted,
		arg.TransactionSource,
		arg.TransactionNumber,
		arg.AccountNumber,
		arg.PhoneNumber,
		arg.PayingName,
		arg.Amount,
		arg.PaidDate,
		arg.AssignTo,
		arg.AssignedBy,
	)
}

const deleteNonPosted = `-- name: DeleteNonPosted :exec
DELETE FROM non_posted WHERE id = ?
`

func (q *Queries) DeleteNonPosted(ctx context.Context, id uint32) error {
	_, err := q.db.ExecContext(ctx, deleteNonPosted, id)
	return err
}

const getClientsNonPosted = `-- name: GetClientsNonPosted :many
SELECT 
    np.id,
    np.transaction_source,
    np.transaction_number,
    np.account_number,
    np.phone_number,
    np.paying_name,
    np.amount,
    np.paid_date,
    np.assign_to,
    np.assigned_by
FROM non_posted np
WHERE 
    (np.assign_to = ?)
    OR (np.account_number = ?)
ORDER BY np.paid_date DESC
LIMIT ? OFFSET ?
`

type GetClientsNonPostedParams struct {
	AssignTo      sql.NullInt32  `json:"assign_to"`
	AccountNumber sql.NullString `json:"account_number"`
	Limit         int32          `json:"limit"`
	Offset        int32          `json:"offset"`
}

type GetClientsNonPostedRow struct {
	ID                uint32                     `json:"id"`
	TransactionSource NonPostedTransactionSource `json:"transaction_source"`
	TransactionNumber string                     `json:"transaction_number"`
	AccountNumber     string                     `json:"account_number"`
	PhoneNumber       string                     `json:"phone_number"`
	PayingName        string                     `json:"paying_name"`
	Amount            float64                    `json:"amount"`
	PaidDate          time.Time                  `json:"paid_date"`
	AssignTo          sql.NullInt32              `json:"assign_to"`
	AssignedBy        string                     `json:"assigned_by"`
}

func (q *Queries) GetClientsNonPosted(ctx context.Context, arg GetClientsNonPostedParams) ([]GetClientsNonPostedRow, error) {
	rows, err := q.db.QueryContext(ctx, getClientsNonPosted,
		arg.AssignTo,
		arg.AccountNumber,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClientsNonPostedRow{}
	for rows.Next() {
		var i GetClientsNonPostedRow
		if err := rows.Scan(
			&i.ID,
			&i.TransactionSource,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PhoneNumber,
			&i.PayingName,
			&i.Amount,
			&i.PaidDate,
			&i.AssignTo,
			&i.AssignedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNonPosted = `-- name: GetNonPosted :one
SELECT 
    np.id, np.transaction_number, np.account_number, np.phone_number, np.paying_name, np.amount, np.assign_to, np.paid_date, np.transaction_source, np.assigned_by, np.deleted_at, np.deleted_description, 
    -- Client Details (if assigned)
    c.id AS client_id,
    c.full_name AS client_name,
    c.phone_number AS client_phone,
    c.overpayment AS client_overpayment,
    b.name AS client_branch_name

FROM non_posted np
LEFT JOIN clients c ON np.assign_to = c.id
LEFT JOIN branches b ON c.branch_id = b.id
WHERE np.id = ? LIMIT 1
`

type GetNonPostedRow struct {
	ID                 uint32                     `json:"id"`
	TransactionNumber  string                     `json:"transaction_number"`
	AccountNumber      string                     `json:"account_number"`
	PhoneNumber        string                     `json:"phone_number"`
	PayingName         string                     `json:"paying_name"`
	Amount             float64                    `json:"amount"`
	AssignTo           sql.NullInt32              `json:"assign_to"`
	PaidDate           time.Time                  `json:"paid_date"`
	TransactionSource  NonPostedTransactionSource `json:"transaction_source"`
	AssignedBy         string                     `json:"assigned_by"`
	DeletedAt          sql.NullTime               `json:"deleted_at"`
	DeletedDescription sql.NullString             `json:"deleted_description"`
	ClientID           sql.NullInt32              `json:"client_id"`
	ClientName         sql.NullString             `json:"client_name"`
	ClientPhone        sql.NullString             `json:"client_phone"`
	ClientOverpayment  sql.NullString             `json:"client_overpayment"`
	ClientBranchName   sql.NullString             `json:"client_branch_name"`
}

func (q *Queries) GetNonPosted(ctx context.Context, id uint32) (GetNonPostedRow, error) {
	row := q.db.QueryRowContext(ctx, getNonPosted, id)
	var i GetNonPostedRow
	err := row.Scan(
		&i.ID,
		&i.TransactionNumber,
		&i.AccountNumber,
		&i.PhoneNumber,
		&i.PayingName,
		&i.Amount,
		&i.AssignTo,
		&i.PaidDate,
		&i.TransactionSource,
		&i.AssignedBy,
		&i.DeletedAt,
		&i.DeletedDescription,
		&i.ClientID,
		&i.ClientName,
		&i.ClientPhone,
		&i.ClientOverpayment,
		&i.ClientBranchName,
	)
	return i, err
}

const getTotalPaidByIDorAccountNo = `-- name: GetTotalPaidByIDorAccountNo :one
SELECT SUM(amount) 
    FROM non_posted
    WHERE 
        (assign_to = ?)
        OR (account_number = ?)
`

type GetTotalPaidByIDorAccountNoParams struct {
	AssignTo      sql.NullInt32  `json:"assign_to"`
	AccountNumber sql.NullString `json:"account_number"`
}

func (q *Queries) GetTotalPaidByIDorAccountNo(ctx context.Context, arg GetTotalPaidByIDorAccountNoParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTotalPaidByIDorAccountNo, arg.AssignTo, arg.AccountNumber)
	var sum interface{}
	err := row.Scan(&sum)
	return sum, err
}

const listAllNonPosted = `-- name: ListAllNonPosted :many
SELECT id, transaction_number, account_number, phone_number, paying_name, amount, assign_to, paid_date, transaction_source, assigned_by, deleted_at, deleted_description FROM non_posted LIMIT ? OFFSET ?
`

type ListAllNonPostedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllNonPosted(ctx context.Context, arg ListAllNonPostedParams) ([]NonPosted, error) {
	rows, err := q.db.QueryContext(ctx, listAllNonPosted, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonPosted{}
	for rows.Next() {
		var i NonPosted
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PhoneNumber,
			&i.PayingName,
			&i.Amount,
			&i.AssignTo,
			&i.PaidDate,
			&i.TransactionSource,
			&i.AssignedBy,
			&i.DeletedAt,
			&i.DeletedDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllNonPostedByTransactionSource = `-- name: ListAllNonPostedByTransactionSource :many
SELECT id, transaction_number, account_number, phone_number, paying_name, amount, assign_to, paid_date, transaction_source, assigned_by, deleted_at, deleted_description FROM non_posted WHERE transaction_source = ?
`

func (q *Queries) ListAllNonPostedByTransactionSource(ctx context.Context, transactionSource NonPostedTransactionSource) ([]NonPosted, error) {
	rows, err := q.db.QueryContext(ctx, listAllNonPostedByTransactionSource, transactionSource)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonPosted{}
	for rows.Next() {
		var i NonPosted
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PhoneNumber,
			&i.PayingName,
			&i.Amount,
			&i.AssignTo,
			&i.PaidDate,
			&i.TransactionSource,
			&i.AssignedBy,
			&i.DeletedAt,
			&i.DeletedDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonPostedByCategory = `-- name: ListNonPostedByCategory :many
SELECT 
    np.id, np.transaction_number, np.account_number, np.phone_number, np.paying_name, np.amount, np.assign_to, np.paid_date, np.transaction_source, np.assigned_by, np.deleted_at, np.deleted_description, 
    -- Client Details (if assigned)
    c.id AS client_id,
    c.full_name AS client_name,
    c.phone_number AS client_phone,
    c.overpayment AS client_overpayment,
    b.name AS client_branch_name

FROM non_posted np
LEFT JOIN clients c ON np.assign_to = c.id
LEFT JOIN branches b ON c.branch_id = b.id

WHERE 
    (
        COALESCE(?, '') = '' 
        OR LOWER(np.paying_name) LIKE ?
        OR LOWER(np.account_number) LIKE ?
        OR LOWER(np.transaction_number) LIKE ?
    )
    AND (
        COALESCE(?, '') = '' 
        OR FIND_IN_SET(np.transaction_source, ?) > 0
    )
    AND paid_date BETWEEN ? AND ?
ORDER BY np.paid_date DESC
LIMIT ? OFFSET ?
`

type ListNonPostedByCategoryParams struct {
	Column1           interface{} `json:"column_1"`
	PayingName        string      `json:"paying_name"`
	AccountNumber     string      `json:"account_number"`
	TransactionNumber string      `json:"transaction_number"`
	Column5           interface{} `json:"column_5"`
	FINDINSET         string      `json:"FIND_IN_SET"`
	FromPaidDate      time.Time   `json:"from_paid_date"`
	ToPaidDate        time.Time   `json:"to_paid_date"`
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
}

type ListNonPostedByCategoryRow struct {
	ID                 uint32                     `json:"id"`
	TransactionNumber  string                     `json:"transaction_number"`
	AccountNumber      string                     `json:"account_number"`
	PhoneNumber        string                     `json:"phone_number"`
	PayingName         string                     `json:"paying_name"`
	Amount             float64                    `json:"amount"`
	AssignTo           sql.NullInt32              `json:"assign_to"`
	PaidDate           time.Time                  `json:"paid_date"`
	TransactionSource  NonPostedTransactionSource `json:"transaction_source"`
	AssignedBy         string                     `json:"assigned_by"`
	DeletedAt          sql.NullTime               `json:"deleted_at"`
	DeletedDescription sql.NullString             `json:"deleted_description"`
	ClientID           sql.NullInt32              `json:"client_id"`
	ClientName         sql.NullString             `json:"client_name"`
	ClientPhone        sql.NullString             `json:"client_phone"`
	ClientOverpayment  sql.NullString             `json:"client_overpayment"`
	ClientBranchName   sql.NullString             `json:"client_branch_name"`
}

func (q *Queries) ListNonPostedByCategory(ctx context.Context, arg ListNonPostedByCategoryParams) ([]ListNonPostedByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listNonPostedByCategory,
		arg.Column1,
		arg.PayingName,
		arg.AccountNumber,
		arg.TransactionNumber,
		arg.Column5,
		arg.FINDINSET,
		arg.FromPaidDate,
		arg.ToPaidDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListNonPostedByCategoryRow{}
	for rows.Next() {
		var i ListNonPostedByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PhoneNumber,
			&i.PayingName,
			&i.Amount,
			&i.AssignTo,
			&i.PaidDate,
			&i.TransactionSource,
			&i.AssignedBy,
			&i.DeletedAt,
			&i.DeletedDescription,
			&i.ClientID,
			&i.ClientName,
			&i.ClientPhone,
			&i.ClientOverpayment,
			&i.ClientBranchName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonPostedByTransactionSource = `-- name: ListNonPostedByTransactionSource :many
SELECT id, transaction_number, account_number, phone_number, paying_name, amount, assign_to, paid_date, transaction_source, assigned_by, deleted_at, deleted_description FROM non_posted WHERE transaction_source = ? LIMIT ? OFFSET ?
`

type ListNonPostedByTransactionSourceParams struct {
	TransactionSource NonPostedTransactionSource `json:"transaction_source"`
	Limit             int32                      `json:"limit"`
	Offset            int32                      `json:"offset"`
}

func (q *Queries) ListNonPostedByTransactionSource(ctx context.Context, arg ListNonPostedByTransactionSourceParams) ([]NonPosted, error) {
	rows, err := q.db.QueryContext(ctx, listNonPostedByTransactionSource, arg.TransactionSource, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonPosted{}
	for rows.Next() {
		var i NonPosted
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PhoneNumber,
			&i.PayingName,
			&i.Amount,
			&i.AssignTo,
			&i.PaidDate,
			&i.TransactionSource,
			&i.AssignedBy,
			&i.DeletedAt,
			&i.DeletedDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnassignedNonPosted = `-- name: ListUnassignedNonPosted :many
SELECT id, transaction_number, account_number, phone_number, paying_name, amount, assign_to, paid_date, transaction_source, assigned_by, deleted_at, deleted_description FROM non_posted WHERE assign_to IS NULL LIMIT ? OFFSET ?
`

type ListUnassignedNonPostedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUnassignedNonPosted(ctx context.Context, arg ListUnassignedNonPostedParams) ([]NonPosted, error) {
	rows, err := q.db.QueryContext(ctx, listUnassignedNonPosted, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonPosted{}
	for rows.Next() {
		var i NonPosted
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PhoneNumber,
			&i.PayingName,
			&i.Amount,
			&i.AssignTo,
			&i.PaidDate,
			&i.TransactionSource,
			&i.AssignedBy,
			&i.DeletedAt,
			&i.DeletedDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteNonPosted = `-- name: SoftDeleteNonPosted :exec
UPDATE non_posted
SET deleted_at = CURRENT_TIMESTAMP,
    deleted_description = ?
WHERE id = ?
`

type SoftDeleteNonPostedParams struct {
	DeletedDescription sql.NullString `json:"deleted_description"`
	ID                 uint32         `json:"id"`
}

func (q *Queries) SoftDeleteNonPosted(ctx context.Context, arg SoftDeleteNonPostedParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteNonPosted, arg.DeletedDescription, arg.ID)
	return err
}

const updateNonPosted = `-- name: UpdateNonPosted :execresult
UPDATE non_posted 
    SET transaction_source = ?,
    transaction_number = ?,
    account_number = ?,
    phone_number = ?,
    paying_name = ?,
    amount = ?,
    paid_date = ?,
    assign_to = COALESCE(?, assign_to),
    assigned_by = ?,
    deleted_description = ?
WHERE id = ?
`

type UpdateNonPostedParams struct {
	TransactionSource  NonPostedTransactionSource `json:"transaction_source"`
	TransactionNumber  string                     `json:"transaction_number"`
	AccountNumber      string                     `json:"account_number"`
	PhoneNumber        string                     `json:"phone_number"`
	PayingName         string                     `json:"paying_name"`
	Amount             float64                    `json:"amount"`
	PaidDate           time.Time                  `json:"paid_date"`
	AssignTo           sql.NullInt32              `json:"assign_to"`
	AssignedBy         string                     `json:"assigned_by"`
	DeletedDescription sql.NullString             `json:"deleted_description"`
	ID                 uint32                     `json:"id"`
}

func (q *Queries) UpdateNonPosted(ctx context.Context, arg UpdateNonPostedParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateNonPosted,
		arg.TransactionSource,
		arg.TransactionNumber,
		arg.AccountNumber,
		arg.PhoneNumber,
		arg.PayingName,
		arg.Amount,
		arg.PaidDate,
		arg.AssignTo,
		arg.AssignedBy,
		arg.DeletedDescription,
		arg.ID,
	)
}
