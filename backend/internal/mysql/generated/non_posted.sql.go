// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: non_posted.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const assignNonPosted = `-- name: AssignNonPosted :execresult
UPDATE non_posted 
    SET assign_to = ?
WHERE id = ?
`

type AssignNonPostedParams struct {
	AssignTo sql.NullInt32 `json:"assign_to"`
	ID       uint32        `json:"id"`
}

func (q *Queries) AssignNonPosted(ctx context.Context, arg AssignNonPostedParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, assignNonPosted, arg.AssignTo, arg.ID)
}

const createNonPosted = `-- name: CreateNonPosted :execresult
INSERT INTO non_posted (transaction_number, account_number, phone_number, paying_name, amount, paid_date) 
VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type CreateNonPostedParams struct {
	TransactionNumber string    `json:"transaction_number"`
	AccountNumber     string    `json:"account_number"`
	PhoneNumber       string    `json:"phone_number"`
	PayingName        string    `json:"paying_name"`
	Amount            float64   `json:"amount"`
	PaidDate          time.Time `json:"paid_date"`
}

func (q *Queries) CreateNonPosted(ctx context.Context, arg CreateNonPostedParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createNonPosted,
		arg.TransactionNumber,
		arg.AccountNumber,
		arg.PhoneNumber,
		arg.PayingName,
		arg.Amount,
		arg.PaidDate,
	)
}

const deleteNonPosted = `-- name: DeleteNonPosted :exec
DELETE FROM non_posted WHERE id = ?
`

func (q *Queries) DeleteNonPosted(ctx context.Context, id uint32) error {
	_, err := q.db.ExecContext(ctx, deleteNonPosted, id)
	return err
}

const getNonPosted = `-- name: GetNonPosted :one
SELECT id, transaction_number, account_number, phone_number, paying_name, amount, assign_to, paid_date FROM non_posted WHERE id = ? LIMIT 1
`

func (q *Queries) GetNonPosted(ctx context.Context, id uint32) (NonPosted, error) {
	row := q.db.QueryRowContext(ctx, getNonPosted, id)
	var i NonPosted
	err := row.Scan(
		&i.ID,
		&i.TransactionNumber,
		&i.AccountNumber,
		&i.PhoneNumber,
		&i.PayingName,
		&i.Amount,
		&i.AssignTo,
		&i.PaidDate,
	)
	return i, err
}

const listAllNonPosted = `-- name: ListAllNonPosted :many
SELECT id, transaction_number, account_number, phone_number, paying_name, amount, assign_to, paid_date FROM non_posted LIMIT ? OFFSET ?
`

type ListAllNonPostedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllNonPosted(ctx context.Context, arg ListAllNonPostedParams) ([]NonPosted, error) {
	rows, err := q.db.QueryContext(ctx, listAllNonPosted, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NonPosted
	for rows.Next() {
		var i NonPosted
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PhoneNumber,
			&i.PayingName,
			&i.Amount,
			&i.AssignTo,
			&i.PaidDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnassignedNonPosted = `-- name: ListUnassignedNonPosted :many
SELECT id, transaction_number, account_number, phone_number, paying_name, amount, assign_to, paid_date FROM non_posted WHERE assign_to IS NULL LIMIT ? OFFSET ?
`

type ListUnassignedNonPostedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUnassignedNonPosted(ctx context.Context, arg ListUnassignedNonPostedParams) ([]NonPosted, error) {
	rows, err := q.db.QueryContext(ctx, listUnassignedNonPosted, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NonPosted
	for rows.Next() {
		var i NonPosted
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PhoneNumber,
			&i.PayingName,
			&i.Amount,
			&i.AssignTo,
			&i.PaidDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
