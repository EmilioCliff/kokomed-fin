// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: non_posted.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const assignNonPosted = `-- name: AssignNonPosted :execresult
UPDATE non_posted 
    SET assign_to = ?,
    transaction_source = ?
WHERE id = ?
`

type AssignNonPostedParams struct {
	AssignTo          sql.NullInt32              `json:"assign_to"`
	TransactionSource NonPostedTransactionSource `json:"transaction_source"`
	ID                uint32                     `json:"id"`
}

func (q *Queries) AssignNonPosted(ctx context.Context, arg AssignNonPostedParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, assignNonPosted, arg.AssignTo, arg.TransactionSource, arg.ID)
}

const countNonPostedByCategory = `-- name: CountNonPostedByCategory :one
SELECT COUNT(*) AS total_non_posted 
FROM non_posted
WHERE 
    (
        COALESCE(?, '') = '' 
        OR LOWER(paying_name) LIKE ?
        OR LOWER(account_number) LIKE ?
        OR LOWER(transaction_number) LIKE ?
    )
    AND (
        COALESCE(?, '') = '' 
        OR FIND_IN_SET(transaction_source, ?) > 0
    )
`

type CountNonPostedByCategoryParams struct {
	Column1           interface{} `json:"column_1"`
	PayingName        string      `json:"paying_name"`
	AccountNumber     string      `json:"account_number"`
	TransactionNumber string      `json:"transaction_number"`
	Column5           interface{} `json:"column_5"`
	FINDINSET         string      `json:"FIND_IN_SET"`
}

func (q *Queries) CountNonPostedByCategory(ctx context.Context, arg CountNonPostedByCategoryParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNonPostedByCategory,
		arg.Column1,
		arg.PayingName,
		arg.AccountNumber,
		arg.TransactionNumber,
		arg.Column5,
		arg.FINDINSET,
	)
	var total_non_posted int64
	err := row.Scan(&total_non_posted)
	return total_non_posted, err
}

const createNonPosted = `-- name: CreateNonPosted :execresult
INSERT INTO non_posted (transaction_source, transaction_number, account_number, phone_number, paying_name, amount, paid_date, assign_to) 
VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreateNonPostedParams struct {
	TransactionSource NonPostedTransactionSource `json:"transaction_source"`
	TransactionNumber string                     `json:"transaction_number"`
	AccountNumber     string                     `json:"account_number"`
	PhoneNumber       string                     `json:"phone_number"`
	PayingName        string                     `json:"paying_name"`
	Amount            float64                    `json:"amount"`
	PaidDate          time.Time                  `json:"paid_date"`
	AssignTo          sql.NullInt32              `json:"assign_to"`
}

func (q *Queries) CreateNonPosted(ctx context.Context, arg CreateNonPostedParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createNonPosted,
		arg.TransactionSource,
		arg.TransactionNumber,
		arg.AccountNumber,
		arg.PhoneNumber,
		arg.PayingName,
		arg.Amount,
		arg.PaidDate,
		arg.AssignTo,
	)
}

const deleteNonPosted = `-- name: DeleteNonPosted :exec
DELETE FROM non_posted WHERE id = ?
`

func (q *Queries) DeleteNonPosted(ctx context.Context, id uint32) error {
	_, err := q.db.ExecContext(ctx, deleteNonPosted, id)
	return err
}

const getNonPosted = `-- name: GetNonPosted :one
SELECT id, transaction_number, account_number, phone_number, paying_name, amount, assign_to, paid_date, transaction_source FROM non_posted WHERE id = ? LIMIT 1
`

func (q *Queries) GetNonPosted(ctx context.Context, id uint32) (NonPosted, error) {
	row := q.db.QueryRowContext(ctx, getNonPosted, id)
	var i NonPosted
	err := row.Scan(
		&i.ID,
		&i.TransactionNumber,
		&i.AccountNumber,
		&i.PhoneNumber,
		&i.PayingName,
		&i.Amount,
		&i.AssignTo,
		&i.PaidDate,
		&i.TransactionSource,
	)
	return i, err
}

const listAllNonPosted = `-- name: ListAllNonPosted :many
SELECT id, transaction_number, account_number, phone_number, paying_name, amount, assign_to, paid_date, transaction_source FROM non_posted LIMIT ? OFFSET ?
`

type ListAllNonPostedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllNonPosted(ctx context.Context, arg ListAllNonPostedParams) ([]NonPosted, error) {
	rows, err := q.db.QueryContext(ctx, listAllNonPosted, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonPosted{}
	for rows.Next() {
		var i NonPosted
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PhoneNumber,
			&i.PayingName,
			&i.Amount,
			&i.AssignTo,
			&i.PaidDate,
			&i.TransactionSource,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllNonPostedByTransactionSource = `-- name: ListAllNonPostedByTransactionSource :many
SELECT id, transaction_number, account_number, phone_number, paying_name, amount, assign_to, paid_date, transaction_source FROM non_posted WHERE transaction_source = ?
`

func (q *Queries) ListAllNonPostedByTransactionSource(ctx context.Context, transactionSource NonPostedTransactionSource) ([]NonPosted, error) {
	rows, err := q.db.QueryContext(ctx, listAllNonPostedByTransactionSource, transactionSource)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonPosted{}
	for rows.Next() {
		var i NonPosted
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PhoneNumber,
			&i.PayingName,
			&i.Amount,
			&i.AssignTo,
			&i.PaidDate,
			&i.TransactionSource,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonPostedByCategory = `-- name: ListNonPostedByCategory :many
SELECT id, transaction_number, account_number, phone_number, paying_name, amount, assign_to, paid_date, transaction_source
FROM non_posted
WHERE 
    (
        COALESCE(?, '') = '' 
        OR LOWER(paying_name) LIKE ?
        OR LOWER(account_number) LIKE ?
        OR LOWER(transaction_number) LIKE ?
    )
    AND (
        COALESCE(?, '') = '' 
        OR FIND_IN_SET(transaction_source, ?) > 0
    )
 ORDER BY paid_date DESC
LIMIT ? OFFSET ?
`

type ListNonPostedByCategoryParams struct {
	Column1           interface{} `json:"column_1"`
	PayingName        string      `json:"paying_name"`
	AccountNumber     string      `json:"account_number"`
	TransactionNumber string      `json:"transaction_number"`
	Column5           interface{} `json:"column_5"`
	FINDINSET         string      `json:"FIND_IN_SET"`
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
}

func (q *Queries) ListNonPostedByCategory(ctx context.Context, arg ListNonPostedByCategoryParams) ([]NonPosted, error) {
	rows, err := q.db.QueryContext(ctx, listNonPostedByCategory,
		arg.Column1,
		arg.PayingName,
		arg.AccountNumber,
		arg.TransactionNumber,
		arg.Column5,
		arg.FINDINSET,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonPosted{}
	for rows.Next() {
		var i NonPosted
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PhoneNumber,
			&i.PayingName,
			&i.Amount,
			&i.AssignTo,
			&i.PaidDate,
			&i.TransactionSource,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonPostedByTransactionSource = `-- name: ListNonPostedByTransactionSource :many
SELECT id, transaction_number, account_number, phone_number, paying_name, amount, assign_to, paid_date, transaction_source FROM non_posted WHERE transaction_source = ? LIMIT ? OFFSET ?
`

type ListNonPostedByTransactionSourceParams struct {
	TransactionSource NonPostedTransactionSource `json:"transaction_source"`
	Limit             int32                      `json:"limit"`
	Offset            int32                      `json:"offset"`
}

func (q *Queries) ListNonPostedByTransactionSource(ctx context.Context, arg ListNonPostedByTransactionSourceParams) ([]NonPosted, error) {
	rows, err := q.db.QueryContext(ctx, listNonPostedByTransactionSource, arg.TransactionSource, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonPosted{}
	for rows.Next() {
		var i NonPosted
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PhoneNumber,
			&i.PayingName,
			&i.Amount,
			&i.AssignTo,
			&i.PaidDate,
			&i.TransactionSource,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnassignedNonPosted = `-- name: ListUnassignedNonPosted :many
SELECT id, transaction_number, account_number, phone_number, paying_name, amount, assign_to, paid_date, transaction_source FROM non_posted WHERE assign_to IS NULL LIMIT ? OFFSET ?
`

type ListUnassignedNonPostedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUnassignedNonPosted(ctx context.Context, arg ListUnassignedNonPostedParams) ([]NonPosted, error) {
	rows, err := q.db.QueryContext(ctx, listUnassignedNonPosted, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NonPosted{}
	for rows.Next() {
		var i NonPosted
		if err := rows.Scan(
			&i.ID,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PhoneNumber,
			&i.PayingName,
			&i.Amount,
			&i.AssignTo,
			&i.PaidDate,
			&i.TransactionSource,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
