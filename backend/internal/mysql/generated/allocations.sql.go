// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: allocations.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const createPaymentAllocation = `-- name: CreatePaymentAllocation :execresult
INSERT INTO payment_allocations (non_posted_id, loan_id, installment_id, amount, description)
VALUES (?, ?, ?, ?, ?)
`

type CreatePaymentAllocationParams struct {
	NonPostedID   uint32        `json:"non_posted_id"`
	LoanID        sql.NullInt32 `json:"loan_id"`
	InstallmentID sql.NullInt32 `json:"installment_id"`
	Amount        float64       `json:"amount"`
	Description   string        `json:"description"`
}

func (q *Queries) CreatePaymentAllocation(ctx context.Context, arg CreatePaymentAllocationParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createPaymentAllocation,
		arg.NonPostedID,
		arg.LoanID,
		arg.InstallmentID,
		arg.Amount,
		arg.Description,
	)
}

const deletePaymentAllocation = `-- name: DeletePaymentAllocation :execresult
UPDATE payment_allocations SET deleted_at = NOW() WHERE id = ?
`

func (q *Queries) DeletePaymentAllocation(ctx context.Context, id uint32) (sql.Result, error) {
	return q.db.ExecContext(ctx, deletePaymentAllocation, id)
}

const deletePaymentAllocationsByNonPostedId = `-- name: DeletePaymentAllocationsByNonPostedId :execresult
UPDATE payment_allocations SET deleted_at = NOW(), deleted_description = ? WHERE non_posted_id = ? AND deleted_at IS NULL
`

type DeletePaymentAllocationsByNonPostedIdParams struct {
	DeletedDescription sql.NullString `json:"deleted_description"`
	NonPostedID        uint32         `json:"non_posted_id"`
}

func (q *Queries) DeletePaymentAllocationsByNonPostedId(ctx context.Context, arg DeletePaymentAllocationsByNonPostedIdParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deletePaymentAllocationsByNonPostedId, arg.DeletedDescription, arg.NonPostedID)
}

const listPaymentAllocationsByLoanId = `-- name: ListPaymentAllocationsByLoanId :many
SELECT 
  pa.id, pa.non_posted_id, pa.loan_id, pa.installment_id, pa.amount, pa.description, pa.deleted_at, pa.deleted_description, pa.created_at,
  np.transaction_source,
  np.transaction_number,
  np.account_number,
  np.paying_name,
  np.amount,
  np.paid_date
FROM payment_allocations pa
JOIN non_posted np ON pa.non_posted_id = np.id
WHERE pa.loan_id = ?
AND pa.deleted_at IS NULL
`

type ListPaymentAllocationsByLoanIdRow struct {
	ID                 uint32                     `json:"id"`
	NonPostedID        uint32                     `json:"non_posted_id"`
	LoanID             sql.NullInt32              `json:"loan_id"`
	InstallmentID      sql.NullInt32              `json:"installment_id"`
	Amount             float64                    `json:"amount"`
	Description        string                     `json:"description"`
	DeletedAt          sql.NullTime               `json:"deleted_at"`
	DeletedDescription sql.NullString             `json:"deleted_description"`
	CreatedAt          time.Time                  `json:"created_at"`
	TransactionSource  NonPostedTransactionSource `json:"transaction_source"`
	TransactionNumber  string                     `json:"transaction_number"`
	AccountNumber      string                     `json:"account_number"`
	PayingName         string                     `json:"paying_name"`
	Amount_2           float64                    `json:"amount_2"`
	PaidDate           time.Time                  `json:"paid_date"`
}

func (q *Queries) ListPaymentAllocationsByLoanId(ctx context.Context, loanID sql.NullInt32) ([]ListPaymentAllocationsByLoanIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentAllocationsByLoanId, loanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPaymentAllocationsByLoanIdRow{}
	for rows.Next() {
		var i ListPaymentAllocationsByLoanIdRow
		if err := rows.Scan(
			&i.ID,
			&i.NonPostedID,
			&i.LoanID,
			&i.InstallmentID,
			&i.Amount,
			&i.Description,
			&i.DeletedAt,
			&i.DeletedDescription,
			&i.CreatedAt,
			&i.TransactionSource,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PayingName,
			&i.Amount_2,
			&i.PaidDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentAllocationsByNonPostedID = `-- name: ListPaymentAllocationsByNonPostedID :many
SELECT 
  pa.id, pa.non_posted_id, pa.loan_id, pa.installment_id, pa.amount, pa.description, pa.deleted_at, pa.deleted_description, pa.created_at,
  np.transaction_source,
  np.transaction_number,
  np.account_number,
  np.paying_name,
  np.amount,
  np.paid_date
FROM payment_allocations pa
JOIN non_posted np ON pa.non_posted_id = np.id
WHERE loan_id IS NULL
  AND non_posted_id = ? AND pa.deleted_at IS NULL
`

type ListPaymentAllocationsByNonPostedIDRow struct {
	ID                 uint32                     `json:"id"`
	NonPostedID        uint32                     `json:"non_posted_id"`
	LoanID             sql.NullInt32              `json:"loan_id"`
	InstallmentID      sql.NullInt32              `json:"installment_id"`
	Amount             float64                    `json:"amount"`
	Description        string                     `json:"description"`
	DeletedAt          sql.NullTime               `json:"deleted_at"`
	DeletedDescription sql.NullString             `json:"deleted_description"`
	CreatedAt          time.Time                  `json:"created_at"`
	TransactionSource  NonPostedTransactionSource `json:"transaction_source"`
	TransactionNumber  string                     `json:"transaction_number"`
	AccountNumber      string                     `json:"account_number"`
	PayingName         string                     `json:"paying_name"`
	Amount_2           float64                    `json:"amount_2"`
	PaidDate           time.Time                  `json:"paid_date"`
}

func (q *Queries) ListPaymentAllocationsByNonPostedID(ctx context.Context, nonPostedID uint32) ([]ListPaymentAllocationsByNonPostedIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentAllocationsByNonPostedID, nonPostedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPaymentAllocationsByNonPostedIDRow{}
	for rows.Next() {
		var i ListPaymentAllocationsByNonPostedIDRow
		if err := rows.Scan(
			&i.ID,
			&i.NonPostedID,
			&i.LoanID,
			&i.InstallmentID,
			&i.Amount,
			&i.Description,
			&i.DeletedAt,
			&i.DeletedDescription,
			&i.CreatedAt,
			&i.TransactionSource,
			&i.TransactionNumber,
			&i.AccountNumber,
			&i.PayingName,
			&i.Amount_2,
			&i.PaidDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentAllocationsByNonPostedId = `-- name: ListPaymentAllocationsByNonPostedId :many
SELECT id, non_posted_id, loan_id, installment_id, amount, description, deleted_at, deleted_description, created_at FROM payment_allocations WHERE non_posted_id = ? AND deleted_at IS NULL
`

func (q *Queries) ListPaymentAllocationsByNonPostedId(ctx context.Context, nonPostedID uint32) ([]PaymentAllocation, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentAllocationsByNonPostedId, nonPostedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentAllocation{}
	for rows.Next() {
		var i PaymentAllocation
		if err := rows.Scan(
			&i.ID,
			&i.NonPostedID,
			&i.LoanID,
			&i.InstallmentID,
			&i.Amount,
			&i.Description,
			&i.DeletedAt,
			&i.DeletedDescription,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
