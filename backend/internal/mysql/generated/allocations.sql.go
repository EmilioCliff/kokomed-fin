// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: allocations.sql

package generated

import (
	"context"
	"database/sql"
)

const createPaymentAllocation = `-- name: CreatePaymentAllocation :execresult
INSERT INTO payment_allocations (non_posted_id, loan_id, installment_id, amount)
VALUES (?, ?, ?, ?)
`

type CreatePaymentAllocationParams struct {
	NonPostedID   uint32        `json:"non_posted_id"`
	LoanID        sql.NullInt32 `json:"loan_id"`
	InstallmentID sql.NullInt32 `json:"installment_id"`
	Amount        float64       `json:"amount"`
}

func (q *Queries) CreatePaymentAllocation(ctx context.Context, arg CreatePaymentAllocationParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createPaymentAllocation,
		arg.NonPostedID,
		arg.LoanID,
		arg.InstallmentID,
		arg.Amount,
	)
}

const deletePaymentAllocation = `-- name: DeletePaymentAllocation :execresult
UPDATE payment_allocations SET deleted_at = NOW() WHERE id = ?
`

func (q *Queries) DeletePaymentAllocation(ctx context.Context, id uint32) (sql.Result, error) {
	return q.db.ExecContext(ctx, deletePaymentAllocation, id)
}

const deletePaymentAllocationsByNonPostedId = `-- name: DeletePaymentAllocationsByNonPostedId :execresult
UPDATE payment_allocations SET deleted_at = NOW() WHERE non_posted_id = ? AND deleted_at IS NOT NULL
`

func (q *Queries) DeletePaymentAllocationsByNonPostedId(ctx context.Context, nonPostedID uint32) (sql.Result, error) {
	return q.db.ExecContext(ctx, deletePaymentAllocationsByNonPostedId, nonPostedID)
}

const listPaymentAllocationsByLoanId = `-- name: ListPaymentAllocationsByLoanId :many
SELECT id, non_posted_id, loan_id, installment_id, amount, deleted_at, created_at FROM payment_allocations WHERE loan_id = ? AND deleted_at IS NOT NULL
`

func (q *Queries) ListPaymentAllocationsByLoanId(ctx context.Context, loanID sql.NullInt32) ([]PaymentAllocation, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentAllocationsByLoanId, loanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentAllocation{}
	for rows.Next() {
		var i PaymentAllocation
		if err := rows.Scan(
			&i.ID,
			&i.NonPostedID,
			&i.LoanID,
			&i.InstallmentID,
			&i.Amount,
			&i.DeletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentAllocationsByNonPostedId = `-- name: ListPaymentAllocationsByNonPostedId :many
SELECT id, non_posted_id, loan_id, installment_id, amount, deleted_at, created_at FROM payment_allocations WHERE non_posted_id = ? AND deleted_at IS NOT NULL
`

func (q *Queries) ListPaymentAllocationsByNonPostedId(ctx context.Context, nonPostedID uint32) ([]PaymentAllocation, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentAllocationsByNonPostedId, nonPostedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentAllocation{}
	for rows.Next() {
		var i PaymentAllocation
		if err := rows.Scan(
			&i.ID,
			&i.NonPostedID,
			&i.LoanID,
			&i.InstallmentID,
			&i.Amount,
			&i.DeletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
